using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml.Serialization;
using Microsoft.Build.Construction;
using Xbim.IfcDomains;
using XbimValidationGenerator.Schema;
using XbimValidationGenerator.Templates;

namespace XbimValidationGenerator
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            var prjPath = GetDirectory(Settings.OutputDir);
            var project = GetProject(prjPath);

            var rules = new[] {Properties.Resources.IFC2X3_rules, Properties.Resources.IFC4_rules};
            var domains = new[] {DomainStructure.LoadIfc2X3(), DomainStructure.LoadIfc4Add1()};

            for (var i = 0; i < rules.Length; i++)
            {
                var data = rules[i];
                Settings.Structure = domains[i];
                var schema = new XmlSerializer(typeof(SchemaRules)).Deserialize(new StringReader(data)) as SchemaRules;
                ProcessSchema(schema, project);
            }
            project.Save();
            Console.Beep(400, 1000);
        }

        private static void ProcessSchema(SchemaRules schema, ProjectRootElement project)
        {
            if (schema == null) throw new ArgumentNullException("schema");
            if (project == null) throw new ArgumentNullException("project");

            foreach (var rules in schema.TypeRulesSet)
            {
                var wrTemplate = new WhereError(rules, schema.Schema);
                ProcessTemplate(wrTemplate, project);

                var rTemplate = new SchemaRule(rules, schema.Schema);
                ProcessTemplate(rTemplate, project);
            }

            var schErrsTmpl = new SchemaErrors(schema);
            ProcessTemplate(schErrsTmpl, project);
        }

        private static void ReferenceProject(ProjectRootElement referenced, ProjectRootElement referencing)
        {
            //get project references 
            const string itemType = "ProjectReference";
            var references = referencing.ItemGroups.FirstOrDefault(g => g.Items.All(i => i.ItemType == itemType)) ??
                             referencing.AddItemGroup();

            var referencedPath = new Uri(referenced.FullPath, UriKind.Absolute);
            var referencingPathString = (Path.GetDirectoryName(referencing.FullPath) ?? "") +
                                        Path.DirectorySeparatorChar;
            var referencingPath = new Uri(referencingPathString, UriKind.Absolute);

            var relPath = referencingPath.MakeRelativeUri(referencedPath).ToString();

            //check if it is not there already
            if (references.Children.Any(c =>
            {
                var itemElement = c as ProjectItemElement;
                return itemElement != null && itemElement.Include == relPath;
            })) return;

            references.AddItem(itemType, relPath, new[]
            {
                new KeyValuePair<string, string>("Project", GetProjectId(referenced)),
                new KeyValuePair<string, string>("Name", Path.GetFileNameWithoutExtension(referenced.FullPath))
            });
        }

        public static ProjectRootElement GetProject(string directoryPath)
        {
            if (!Directory.Exists(directoryPath)) Directory.CreateDirectory(directoryPath);
            var projFile =
                Directory.EnumerateFiles(directoryPath, "*.csproj", SearchOption.TopDirectoryOnly).FirstOrDefault();
            return  OpenProject(projFile);
        }

        private static string GetDirectory(string suggestedPath)
        {
            var path = string.IsNullOrWhiteSpace(suggestedPath) ? Environment.CurrentDirectory : suggestedPath;

            if (!Directory.Exists(path))
                Directory.CreateDirectory(path);

            return path;
        }

        private static void WriteHeader(ICodeTemplate template)
        {
            template.WriteLine("// ------------------------------------------------------------------------------");
            template.WriteLine("// <auto-generated>");
            template.WriteLine("//     This code was generated by a tool Xbim.CodeGeneration ");
            //this causes source control to pick up ALL the files because they got changed even if they are de-facto the same
            //template.WriteLine("//		{0}", DateTime.Now.ToString("dd/MM/yyyy hh:mm:ss"));
            template.WriteLine("//  ");
            template.WriteLine("//     Changes to this file may cause incorrect behaviour and will be lost if");
            template.WriteLine("//     the code is regenerated.");
            template.WriteLine("// </auto-generated>");
            template.WriteLine("// ------------------------------------------------------------------------------");
        }

        private static readonly Regex CustomCodeRegex = new Regex("(//##).*?(//##)", RegexOptions.Singleline);

        private static Dictionary<string, string> GetSections(string content)
        {
            var result = new Dictionary<string, string>();
            var sections = CustomCodeRegex.Matches(content);
            foreach (Match section in sections)
            {
                var fli = section.Value.IndexOf('\n');
                var name = section.Value.Substring(0, fli).TrimStart('/', '#').Trim();
                result.Add(name, section.Value);
            }
            return result;
        }

        private static void ProcessTemplate(ICodeTemplate template, ProjectRootElement project)
        {
            var rootNamespace = GetNamespace(project);
            var localNamespace = template.Namespace.Substring(rootNamespace.Length);

            var fileName = template.Name + ".cs";
            var localPath = Path.Combine(localNamespace.Split(new[] { '.' }, StringSplitOptions.RemoveEmptyEntries));
            var projectPath = Path.GetDirectoryName(project.FullPath) ?? "";
            var fullPath = Path.Combine(projectPath, localPath);

            if (!Directory.Exists(fullPath) && !String.IsNullOrWhiteSpace(fullPath))
                Directory.CreateDirectory(fullPath);

            var filePath = Path.Combine(fullPath, fileName);

            WriteHeader(template);
            var code = template.TransformText();
            //it is possible to keep in custom code if there are predefined slots for it
            if (code.Contains("//##") && File.Exists(filePath))
            {
                var oldFile = File.ReadAllText(filePath);
                var oldSections = GetSections(oldFile);
                var newSections = GetSections(code);

                foreach (var section in newSections)
                {
                    var name = section.Key;
                    string value;
                    if (oldSections.TryGetValue(name, out value))
                        code = code.Replace(section.Value, value);
                }
            }



            using (var file = File.CreateText(filePath))
            {
                file.Write(code);
                file.Close();
            }

            var projectFilePath = Path.Combine(localPath, fileName);
            AddCompilationItem(projectFilePath, project);
        }

        private static string GetNamespace(ProjectRootElement project)
        {
            var element =
                project.PropertyGroups.Select(
                    g => g.Children.FirstOrDefault(e => ((ProjectPropertyElement)e).Name == "RootNamespace"))
                    .FirstOrDefault(e => e != null) as ProjectPropertyElement;
            return element != null ? element.Value : Path.GetFileNameWithoutExtension(project.FullPath);
        }

        private static string GetProjectId(ProjectRootElement project)
        {
            var element =
                project.PropertyGroups.Select(
                    g => g.Children.FirstOrDefault(e => ((ProjectPropertyElement)e).Name == "ProjectGuid"))
                    .FirstOrDefault(e => e != null) as ProjectPropertyElement;
            return element != null ? element.Value : "";
        }


        private static ProjectRootElement OpenProject(string path)
        {
            var projElement = ProjectRootElement.Open(path);
            if (projElement == null)
                throw new Exception("Failed to open existing CS project: " + path);

            return projElement;
        }

        public static void AddCompilationItem(string item, ProjectRootElement project)
        {
            const string itemType = "Compile";
            var includes = project.ItemGroups.FirstOrDefault(g => g.Items.All(i => i.ItemType == itemType)) ??
                           project.AddItemGroup();

            //check if it is not there already
            if (includes.Children.Any(c =>
            {
                var itemElement = c as ProjectItemElement;
                return itemElement != null && itemElement.Include == item;
            })) return;

            includes.AddItem(itemType, item);
        }

        public static void RemoveCompilationItem(string item, ProjectRootElement project)
        {
            const string itemType = "Compile";
            var includes = project.ItemGroups.FirstOrDefault(g => g.Items.All(i => i.ItemType == itemType)) ??
                           project.AddItemGroup();

            //check if it is not there already
            var existing = includes.Children.FirstOrDefault(c =>
            {
                var itemElement = c as ProjectItemElement;
                return itemElement != null && itemElement.Include == item;
            });
            if (existing == null) return;
            includes.RemoveChild(existing);
        }
    }
}
