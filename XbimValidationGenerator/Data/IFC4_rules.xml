<?xml version="1.0" encoding="utf-8"?>
<SchemaRules xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Schema="IFC4">
  <TypeRulesSet>
    <TypeRules Type="IfcActorRole">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>If the attribute Role has the enumeration value USERDEFINED then a value for the attribute UserDefinedRole shall be asserted.</Description>
          <Definition> (Role &lt;&gt; IfcRoleEnum.USERDEFINED) OR
((Role = IfcRoleEnum.USERDEFINED) AND
  EXISTS(SELF.UserDefinedRole))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAddress">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Either attribute value Purpose is not given, or when attribute Purpose has enumeration value USERDEFINED then attribute UserDefinedPurpose shall also have a value.</Description>
          <Definition> (NOT(EXISTS(Purpose))) OR
((Purpose &lt;&gt; IfcAddressTypeEnum.USERDEFINED) OR
((Purpose = IfcAddressTypeEnum.USERDEFINED) AND
  EXISTS(SELF.UserDefinedPurpose)))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPerson">
      <WhereRules>
        <WhereRule Name="IdentifiablePerson">
          <Description>Requires that the identification or/ and the family name or/ and the given name is provided as minimum information.</Description>
          <Definition> EXISTS(Identification) OR EXISTS(FamilyName) OR EXISTS(GivenName)</Definition>
        </WhereRule>
        <WhereRule Name="ValidSetOfNames">
          <Description>If middle names are provided, the family name or/ and the given name shall be provided too.</Description>
          <Definition> NOT EXISTS(MiddleNames) OR EXISTS(FamilyName) OR EXISTS(GivenName)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPostalAddress">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Requires that at least one attribute of internal location, address lines, town, region or country is asserted. It is not acceptable to have a postal address without at least one of these values.</Description>
          <Definition> EXISTS (InternalLocation) OR 
EXISTS (AddressLines) OR
EXISTS (PostalBox) OR
EXISTS (PostalCode) OR
EXISTS (Town) OR 
EXISTS (Region) OR  
EXISTS (Country)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTelecomAddress">
      <WhereRules>
        <WhereRule Name="MinimumDataProvided">
          <Description>Requires that at least one attribute of telephone numbers, facsimile numbers, pager number, electronic mail addresses, world wide web home page URL, or messaging ID is asserted. It is not acceptable to have a telecommunications address without at least one of these values.</Description>
          <Definition> EXISTS (TelephoneNumbers) OR
EXISTS (FacsimileNumbers) OR 
EXISTS (PagerNumber) OR
EXISTS (ElectronicMailAddresses) OR 
EXISTS (WWWHomePageURL) OR
EXISTS (MessagingIDs)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcApproval">
      <WhereRules>
        <WhereRule Name="HasIdentifierOrName">
          <Description>Either Identifier or Name (or both) by which the approval is known shall be given.</Description>
          <Definition> EXISTS (Identifier) OR EXISTS (Name)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDoorLiningProperties">
      <WhereRules>
        <WhereRule Name="WR31">
          <Description>Either both parameter, LiningDepth and LiningThickness are given, or only the LiningThickness, then the LiningDepth is variable. It is not valid to only assert the LiningDepth. 

NOTE  A LiningDepth with NIL ($) value indicates a door style with a lining equal to the wall thickness.</Description>
          <Definition> NOT(EXISTS(LiningDepth) AND NOT(EXISTS(LiningThickness)))</Definition>
        </WhereRule>
        <WhereRule Name="WR32">
          <Description>Either both parameter, ThresholdDepth and ThresholdThickness are given, or only the ThresholdThickness, then the ThresholdDepth is variable. It is not valid to only assert the ThresholdDepth. 

NOTE  A ThresholdDepth with NIL ($) value indicates a door style with a lining equal to the wall thickness.</Description>
          <Definition> NOT(EXISTS(ThresholdDepth) AND NOT(EXISTS(ThresholdThickness)))</Definition>
        </WhereRule>
        <WhereRule Name="WR33">
          <Description>Either both parameter, TransomDepth and TransomThickness are given, or none of them.</Description>
          <Definition> (EXISTS(TransomOffset) AND EXISTS(TransomThickness)) XOR
(NOT(EXISTS(TransomOffset)) AND NOT(EXISTS(TransomThickness)))</Definition>
        </WhereRule>
        <WhereRule Name="WR34">
          <Description>Either both parameter, the CasingDepth and the CasingThickness, are given, or none of them.</Description>
          <Definition> (EXISTS(CasingDepth) AND EXISTS(CasingThickness)) XOR
(NOT(EXISTS(CasingDepth)) AND NOT(EXISTS(CasingThickness)))</Definition>
        </WhereRule>
        <WhereRule Name="WR35">
          <Description>The IfcDoorLiningProperties shall only be used in the context of an IfcDoorType. 

NOTE  The deprecated entity IfcDoorStyle is applicable as well.</Description>
          <Definition> (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) 
AND 
(
 ('IFC4.IFCDOORTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))
  OR
 ('IFC4.IFCDOORSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))
)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDoorPanelProperties">
      <WhereRules>
        <WhereRule Name="ApplicableToType">
          <Description>The IfcDoorPanelProperties shall only be used in the context of an IfcDoorType. 

NOTE  The deprecated entity IfcDoorStyle is applicable as well.</Description>
          <Definition> (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) 
AND 
(
 ('IFC4.IFCDOORTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))
  OR
 ('IFC4.IFCDOORSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))
)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWindowLiningProperties">
      <WhereRules>
        <WhereRule Name="WR31">
          <Description>Either both parameter, LiningDepth and LiningThickness are given, or only the LiningThickness, then the LiningDepth is variable. It is not valid to only assert the LiningDepth. 

NOTE  A LiningDepth with NIL ($) value indicates a window style with a lining equal to the wall thickness.</Description>
          <Definition> NOT(EXISTS(LiningDepth) AND NOT(EXISTS(LiningThickness)))</Definition>
        </WhereRule>
        <WhereRule Name="WR32">
          <Description>Either both parameter, FirstTransomOffset and SecondTransomOffset are given, or only the FirstTransomOffset, or none of both. It is not valid to only assert the SecondTransomOffset.</Description>
          <Definition> NOT(NOT(EXISTS(FirstTransomOffset)) AND EXISTS(SecondTransomOffset))</Definition>
        </WhereRule>
        <WhereRule Name="WR33">
          <Description>Either both parameter, FirstMullionOffset and SecondMullionOffset are given, or only the FirstMullionOffset, or none of both. It is not valid to only assert the SecondMullionOffset.</Description>
          <Definition> NOT(NOT(EXISTS(FirstMullionOffset)) AND EXISTS(SecondMullionOffset))</Definition>
        </WhereRule>
        <WhereRule Name="WR34">
          <Description>The IfcWindowPanelProperties shall only be used in the context of an IfcDoorType. 

NOTE  The deprecated entity IfcWindowStyle is applicable as well.</Description>
          <Definition> (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) 
AND 
(
 ('IFC4.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))
  OR
 ('IFC4.IFCWINDOWSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))
)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWindowPanelProperties">
      <WhereRules>
        <WhereRule Name="ApplicableToType">
          <Description>The IfcWindowPanelProperties shall only be used in the context of an IfcDoorType. 

NOTE  The deprecated entity IfcWindowStyle is applicable as well.</Description>
          <Definition> (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) 
AND 
(
 ('IFC4.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))
  OR
 ('IFC4.IFCWINDOWSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))
)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcActuator">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcActuatorType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcActuatorTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcActuatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no actuator type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcActuatorType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
('IFC4.IFCACTUATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAlarm">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcAlarmType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcAlarmTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcAlarmTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no alarm type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcAlarmType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
('IFC4.IFCALARMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcController">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcControllerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcControllerTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcControllerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no controller type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcControllerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
('IFC4.IFCCONTROLLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFlowInstrument">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcFlowInstrumentType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcFlowInstrumentTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcFlowInstrumentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no flow instrument type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcFlowInstrumentType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
('IFC4.IFCFLOWINSTRUMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSensor">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcSensorType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcSensorTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcSensorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no sensor type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcSensorType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
('IFC4.IFCSENSORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcUnitaryControlElement">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcUnitaryControlElementType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcUnitaryControlElementTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcUnitaryControlElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no unitary control element type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcUnitaryControlElementType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
('IFC4.IFCUNITARYCONTROLELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcConstraint">
      <WhereRules>
        <WhereRule Name="WR11">
          <Description>The attribute UserDefinedGrade must be asserted when the value of the IfcConstraintGradeEnum is set to USERDEFINED.</Description>
          <Definition> (ConstraintGrade &lt;&gt; IfcConstraintEnum.USERDEFINED) OR
((ConstraintGrade = IfcConstraintEnum.USERDEFINED) AND EXISTS(SELF\IfcConstraint.UserDefinedGrade))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcObjective">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>The attribute UserDefinedQualifier must be asserted when the value of the ObjectiveQualifier is set to USERDEFINED.</Description>
          <Definition> (ObjectiveQualifier &lt;&gt; IfcObjectiveEnum.USERDEFINED) OR
((ObjectiveQualifier = IfcObjectiveEnum.USERDEFINED) AND EXISTS(SELF\IfcObjective.UserDefinedQualifier))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDayInMonthNumber">
      <WhereRules>
        <WhereRule Name="ValidRange">
          <Description>The valid range for positioning a day in a month is min inclusive = 1 and max inclusive = 31.</Description>
          <Definition> {1 &lt;= SELF &lt;= 31}</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDayInWeekNumber">
      <WhereRules>
        <WhereRule Name="ValidRange">
          <Description>The valid range for positioning a day in a week is min inclusive = 1 and max inclusive = 7.</Description>
          <Definition> {1 &lt;= SELF &lt;= 7}</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcMonthInYearNumber">
      <WhereRules>
        <WhereRule Name="ValidRange">
          <Description>The valid range for positioning a month in a year is min inclusive = 1 and max inclusive = 12.</Description>
          <Definition> {1 &lt;= SELF &lt;= 12}</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAudioVisualAppliance">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcAudioVisualApplianceType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcAudioVisualApplianceTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcAudioVisualApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no audio visual appliance type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcAudioVisualApplianceType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCAUDIOVISUALAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCableCarrierFitting">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCableCarrierFittingType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCableCarrierFittingTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCableCarrierFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no cable carrier fitting type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCableCarrierFittingType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCABLECARRIERFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCableCarrierSegment">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCableCarrierSegmentType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCableCarrierSegmentTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCableCarrierSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no cable carrier segment type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCableCarrierSegmentType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCABLECARRIERSEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCableFitting">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCableFittingType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCableFittingTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCableFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no cable fitting type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCableFittingType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCABLEFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCableSegment">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCableSegmentType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCableSegmentTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCableSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no cable segment type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCableSegmentType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCABLESEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCommunicationsAppliance">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCommunicationsApplianceType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCommunicationsApplianceTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCommunicationsApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no communications appliance type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCommunicationsApplianceType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCOMMUNICATIONSAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcElectricAppliance">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcElectricApplianceType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcElectricApplianceTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcElectricApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no electric appliance type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcElectricApplianceType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCELECTRICAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcElectricDistributionBoard">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcElectricDistributionBoardType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcElectricDistributionBoardTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcElectricDistributionBoardTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no electric distribution board type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcElectricDistributionBoardType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCELECTRICDISTRIBUTIONBOARDTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcElectricFlowStorageDevice">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcElectricFlowStorageDeviceType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no electric flow storage device type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcElectricFlowStorageDeviceType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCELECTRICFLOWSTORAGEDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcElectricGenerator">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcElectricGeneratorType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcElectricGeneratorTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcElectricGeneratorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no electric generator type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcElectricGeneratorType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCELECTRICGENERATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcElectricMotor">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcElectricMotorType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcElectricMotorTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcElectricMotorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no electric motor type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcElectricMotorType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCELECTRICMOTORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcElectricTimeControl">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcElectricTimeControlType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcElectricTimeControlTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcElectricTimeControlTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no electric time control type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcElectricTimeControlType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCELECTRICTIMECONTROLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcJunctionBox">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcJunctionBoxType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcJunctionBoxTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcJunctionBoxTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no junction box type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcJunctionBoxType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCJUNCTIONBOXTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcLamp">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcLampType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcLampTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcLampTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no lamp type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcLampType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCLAMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcLightFixture">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcLightFixtureType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcLightFixtureTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcLightFixtureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no light fixture type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcLightFixtureType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCLIGHTFIXTURETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcMotorConnection">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcMotorConnectionType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcMotorConnectionTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcMotorConnectionTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no motor connection type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcMotorConnectionType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCMOTORCONNECTIONTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcOutlet">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcOutletType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcOutletTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcOutletTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no outlet type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcOutletType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCOUTLETTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcProtectiveDevice">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcProtectiveDeviceType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcProtectiveDeviceTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcProtectiveDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no protective device type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcProtectiveDeviceType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCPROTECTIVEDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcProtectiveDeviceTrippingUnit">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcProtectiveDeviceTrippingUnitType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no protective device tripping unit type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcProtectiveDeviceTrippingUnitType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCPROTECTIVEDEVICETRIPPINGUNITTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSwitchingDevice">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcSwitchingDeviceType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcSwitchingDeviceTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcSwitchingDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no switching device type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcSwitchingDeviceType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCSWITCHINGDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTransformer">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcTransformerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcTransformerTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcTransformerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no transformer type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcTransformerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCTRANFORMERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDocumentReference">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>A name should only be given, if no document information (including the document name) is attached</Description>
          <Definition> EXISTS(Name) XOR EXISTS(ReferencedDocument)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcExternalReference">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>One of the attributes of IfcExternalReference should have a value assigned.</Description>
          <Definition> EXISTS(Identification) OR EXISTS(Location) OR EXISTS(Name)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcGridAxis">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>The dimensionality of the grid axis is 2.</Description>
          <Definition> AxisCurve.Dim = 2</Definition>
        </WhereRule>
        <WhereRule Name="WR2">
          <Description>The IfcGridAxis needs to be used by exactly one of the three attributes of IfcGrid:  
• UAxes 
• VAxes 
• WAxes  i.e. it can only refer to a single instance of IfcGrid in one of the three list of axes.</Description>
          <Definition> (SIZEOF(PartOfU) = 1) XOR (SIZEOF(PartOfV) = 1) XOR (SIZEOF(PartOfW) = 1)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcLocalPlacement">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>Ensures that a 3D local placement can only be relative (if exists) to a 3D parent local placement (and not to a 2D parent local placement).</Description>
          <Definition> IfcCorrectLocalPlacement(RelativePlacement, PlacementRelTo)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAdvancedBrep">
      <WhereRules>
        <WhereRule Name="HasAdvancedFaces">
          <Description>Each face of the advanced B-rep shall be of type IfcAdvancedFace.</Description>
          <Definition> SIZEOF(QUERY(Afs &lt;* SELF\IfcManifoldSolidBrep.Outer.CfsFaces |
  (NOT ('IFC4.IFCADVANCEDFACE' IN TYPEOF(Afs)))
)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAdvancedBrepWithVoids">
      <WhereRules>
        <WhereRule Name="VoidsHaveAdvancedFaces">
          <Description>Each face of the voids within the advanced B-rep with voids shall be of type IfcAdvancedFace.</Description>
          <Definition> SIZEOF (QUERY (Vsh &lt;* Voids |
  SIZEOF (QUERY (Afs &lt;* Vsh.CfsFaces |
  (NOT ('IFC4.IFCADVANCEDFACE' IN TYPEOF(Afs)))
  )) = 0
)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBooleanClippingResult">
      <WhereRules>
        <WhereRule Name="FirstOperandType">
          <Description>The first operand of the Boolean clipping operation shall be either an IfcSweptAreaSolid or (in case of more than one clipping) an IfcBooleanResult.</Description>
          <Definition> ('IFC4.IFCSWEPTAREASOLID' IN TYPEOF(FirstOperand)) OR 
('IFC4.IFCSWEPTDISCSOLID' IN TYPEOF(FirstOperand)) OR 
('IFC4.IFCBOOLEANCLIPPINGRESULT' IN TYPEOF(FirstOperand))</Definition>
        </WhereRule>
        <WhereRule Name="SecondOperandType">
          <Description>The second operand of the Boolean clipping operation shall be an IfcHalfSpaceSolid.</Description>
          <Definition> ('IFC4.IFCHALFSPACESOLID' IN TYPEOF(SecondOperand))</Definition>
        </WhereRule>
        <WhereRule Name="OperatorType">
          <Description>The Boolean operator for clipping is always "Difference".</Description>
          <Definition> Operator = DIFFERENCE</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBooleanResult">
      <WhereRules>
        <WhereRule Name="SameDim">
          <Description>The dimensionality of the first operand shall be the same as the dimensionality of the second operand.</Description>
          <Definition> FirstOperand.Dim = SecondOperand.Dim</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBoxedHalfSpace">
      <WhereRules>
        <WhereRule Name="UnboundedSurface">
          <Description>The BaseSurface defining the half space shall not be a bounded surface.</Description>
          <Definition> NOT ('IFC4.IFCCURVEBOUNDEDPLANE' IN TYPEOF(SELF\IfcHalfSpaceSolid.BaseSurface))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcExtrudedAreaSolid">
      <WhereRules>
        <WhereRule Name="ValidExtrusionDirection">
          <Description>The ExtrudedDirection shall not be perpendicular to the local z-axis. &lt;/EPM-HTML</Description>
          <Definition> IfcDotProduct(IfcRepresentationItem() || IfcGeometricRepresentationItem() || IfcDirection([0.0,0.0,1.0]), SELF.ExtrudedDirection) &lt;&gt; 0.0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcExtrudedAreaSolidTapered">
      <WhereRules>
        <WhereRule Name="CorrectProfileAssignment">
          <Description>The SweptArea as start profile and the EndSweptArea as end profile shall be compatible.</Description>
          <Definition> IfcTaperedSweptAreaProfiles(SELF\IfcSweptAreaSolid.SweptArea, SELF.EndSweptArea)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFixedReferenceSweptAreaSolid">
      <WhereRules>
        <WhereRule Name="DirectrixBounded">
          <Description>If the values for StartParam or EndParam are omited, then the Directrix has to be a bounded or closed curve.</Description>
          <Definition> (EXISTS(StartParam) AND EXISTS(EndParam)) OR 
(SIZEOF(['IFC4.IFCCONIC', 'IFC4.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcGeometricCurveSet">
      <WhereRules>
        <WhereRule Name="NoSurfaces">
          <Description>No surface shall be included in this geometric set.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* SELF\IfcGeometricSet.Elements |
'IFC4.IFCSURFACE' IN TYPEOF(Temp))) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcGeometricSet">
      <WhereRules>
        <WhereRule Name="ConsistentDim">
          <Description>All elements within a geometric set shall have the same dimensionality.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* Elements |
  Temp.Dim &lt;&gt; Elements[1].Dim))
= 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPolygonalBoundedHalfSpace">
      <WhereRules>
        <WhereRule Name="BoundaryDim">
          <Description>The bounding polyline should have the dimensionality of 2.</Description>
          <Definition> PolygonalBoundary.Dim = 2</Definition>
        </WhereRule>
        <WhereRule Name="BoundaryType">
          <Description>Only bounded curves of type IfcCompositeCurve, or IfcPolyline are valid boundaries.</Description>
          <Definition> SIZEOF(TYPEOF(PolygonalBoundary) * [
  'IFC4.IFCPOLYLINE', 
  'IFC4.IFCCOMPOSITECURVE']
) = 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRevolvedAreaSolid">
      <WhereRules>
        <WhereRule Name="AxisStartInXY">
          <Description>The start of the axis shall lie in the XY plane of the position coordinate system.</Description>
          <Definition> Axis.Location.Coordinates[3] = 0.0</Definition>
        </WhereRule>
        <WhereRule Name="AxisDirectionInXY">
          <Description>The direction of the axis shall be parallel to the XY plane of the position coordinate system.</Description>
          <Definition> Axis.Z.DirectionRatios[3] = 0.0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRevolvedAreaSolidTapered">
      <WhereRules>
        <WhereRule Name="CorrectProfileAssignment">
          <Description>The SweptArea as start profile and the EndSweptArea as end profile shall be compatible.</Description>
          <Definition> IfcTaperedSweptAreaProfiles(SELF\IfcSweptAreaSolid.SweptArea, SELF.EndSweptArea)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSectionedSpine">
      <WhereRules>
        <WhereRule Name="CorrespondingSectionPositions">
          <Description>The set of cross sections and the set of cross section positions shall be of the same size.</Description>
          <Definition> SIZEOF(CrossSections) = SIZEOF(CrossSectionPositions)</Definition>
        </WhereRule>
        <WhereRule Name="ConsistentProfileTypes">
          <Description>The profile type (either AREA or CURVE) shall be consistent within the list of the profiles defining the cross sections.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* CrossSections | CrossSections[1].ProfileType &lt;&gt; temp.ProfileType)) = 0</Definition>
        </WhereRule>
        <WhereRule Name="SpineCurveDim">
          <Description>The curve entity which is the underlying spine curve shall have the dimensionality of 3.</Description>
          <Definition> SpineCurve.Dim = 3</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSurfaceCurveSweptAreaSolid">
      <WhereRules>
        <WhereRule Name="DirectrixBounded">
          <Description>If the values for StartParam or EndParam are omited, then the Directrix has to be a bounded or closed curve.</Description>
          <Definition> (EXISTS(StartParam) AND EXISTS(EndParam)) OR 
(SIZEOF(['IFC4.IFCCONIC', 'IFC4.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSweptAreaSolid">
      <WhereRules>
        <WhereRule Name="SweptAreaType">
          <Description>The profile definition for the swept area solid shall be of type AREA.</Description>
          <Definition> SweptArea.ProfileType = IfcProfileTypeEnum.Area</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSweptDiskSolid">
      <WhereRules>
        <WhereRule Name="DirectrixDim">
          <Description>The Directrix shall be a curve in three dimensional space.</Description>
          <Definition> Directrix.Dim = 3</Definition>
        </WhereRule>
        <WhereRule Name="InnerRadiusSize">
          <Description>If InnerRadius exists then Radius denoting the outer radius shall be greater than InnerRadius.</Description>
          <Definition> (NOT EXISTS(InnerRadius)) OR (Radius &gt; InnerRadius)</Definition>
        </WhereRule>
        <WhereRule Name="DirectrixBounded">
          <Description>If the values for StartParam or EndParam are omited, then the Directrix has to be a bounded or closed curve.</Description>
          <Definition> (EXISTS(StartParam) AND EXISTS(EndParam)) OR 
(SIZEOF(['IFC4.IFCCONIC', 'IFC4.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSweptDiskSolidPolygonal">
      <WhereRules>
        <WhereRule Name="CorrectRadii">
          <Description>If a FilletRadius is given, it has to be greater or equal to the Radius of the disk.</Description>
          <Definition> NOT(EXISTS(FilletRadius)) OR (FilletRadius &gt;= SELF\IfcSweptDiskSolid.Radius)</Definition>
        </WhereRule>
        <WhereRule Name="DirectrixIsPolyline">
          <Description>The Directrix shall be of type IfcPolyline.</Description>
          <Definition> 'IFC4.IFCPOLYLINE' IN TYPEOF(SELF\IfcSweptDiskSolid.Directrix)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAxis1Placement">
      <WhereRules>
        <WhereRule Name="AxisIs3D">
          <Description>The Axis when given should only reference a three-dimensional IfcDirection.</Description>
          <Definition> (NOT (EXISTS (Axis))) OR (Axis.Dim = 3)</Definition>
        </WhereRule>
        <WhereRule Name="LocationIs3D">
          <Description>The Cartesian point defining the Location shall have the dimensionality of 3.</Description>
          <Definition> SELF\IfcPlacement.Location.Dim = 3</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAxis2Placement3D">
      <WhereRules>
        <WhereRule Name="LocationIs3D">
          <Description>The dimensionality of the placement location shall be 3.</Description>
          <Definition> SELF\IfcPlacement.Location.Dim = 3</Definition>
        </WhereRule>
        <WhereRule Name="AxisIs3D">
          <Description>The Axis when given should only reference a three-dimensional IfcDirection.</Description>
          <Definition> (NOT (EXISTS (Axis))) OR (Axis.Dim = 3)</Definition>
        </WhereRule>
        <WhereRule Name="RefDirIs3D">
          <Description>The RefDirection when given should only reference a three-dimensional IfcDirection.</Description>
          <Definition> (NOT (EXISTS (RefDirection))) OR (RefDirection.Dim = 3)</Definition>
        </WhereRule>
        <WhereRule Name="AxisToRefDirPosition">
          <Description>The Axis and RefDirection shall not be parallel or anti-parallel.</Description>
          <Definition> (NOT (EXISTS (Axis))) OR (NOT (EXISTS (RefDirection))) OR (IfcCrossProduct(Axis,RefDirection).Magnitude &gt; 0.0)</Definition>
        </WhereRule>
        <WhereRule Name="AxisAndRefDirProvision">
          <Description>Either both, Axis and RefDirection are not given and therefore defaulted, or both shall be given.</Description>
          <Definition> NOT ((EXISTS (Axis)) XOR (EXISTS (RefDirection)))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBoundaryCurve">
      <WhereRules>
        <WhereRule Name="IsClosed">
          <Description>The derived ClosedCurve attribute of IfcCompositeCurve supertype shall be TRUE.</Description>
          <Definition> SELF\IfcCompositeCurve.ClosedCurve</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBSplineCurve">
      <WhereRules>
        <WhereRule Name="SameDim">
          <Description>All control points shall have the same dimensionality.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* ControlPointsList |
  Temp.Dim &lt;&gt; ControlPointsList[1].Dim))
= 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBSplineCurveWithKnots">
      <WhereRules>
        <WhereRule Name="ConsistentBSpline">
          <Description>The function IfcConstraintsParamBSpline returns TRUE if no inconsistencies in the parametrisation of the B-spline are found.</Description>
          <Definition> IfcConstraintsParamBSpline(Degree, UpperIndexOnKnots,
UpperIndexOnControlPoints, KnotMultiplicities, Knots)</Definition>
        </WhereRule>
        <WhereRule Name="CorrespondingKnotLists">
          <Description>The number of elements in the knot multiplicities list shall be equal to the number of elements in the knots list.</Description>
          <Definition> SIZEOF(KnotMultiplicities) = UpperIndexOnKnots</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBSplineSurfaceWithKnots">
      <WhereRules>
        <WhereRule Name="UDirectionConstraints">
          <Description>The function returns TRUE when the parameter constraints are verified for the u direction.</Description>
          <Definition> IfcConstraintsParamBSpline (
  SELF\IfcBSplineSurface.UDegree, KnotUUpper, 
  SELF\IfcBSplineSurface.UUpper, UMultiplicities, UKnots)</Definition>
        </WhereRule>
        <WhereRule Name="VDirectionConstraints">
          <Description>The function returns TRUE when the parameter constraints are verified for the v direction.</Description>
          <Definition> IfcConstraintsParamBSpline (
  SELF\IfcBSplineSurface.VDegree, KnotVUpper, 
  SELF\IfcBSplineSurface.VUpper, VMultiplicities, VKnots)</Definition>
        </WhereRule>
        <WhereRule Name="CorrespondingULists">
          <Description>The number of UMultiplicities shall be the same as the number of UKnots.</Description>
          <Definition> SIZEOF(UMultiplicities) = KnotUUpper</Definition>
        </WhereRule>
        <WhereRule Name="CorrespondingVLists">
          <Description>The number of VMultiplicities shall be the same as the number of VKnots.</Description>
          <Definition> SIZEOF(VMultiplicities) = KnotVUpper</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCartesianPoint">
      <WhereRules>
        <WhereRule Name="CP2Dor3D">
          <Description>Only two or three dimensional points are in scope.</Description>
          <Definition> HIINDEX(Coordinates) &gt;= 2</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCartesianTransformationOperator">
      <WhereRules>
        <WhereRule Name="ScaleGreaterZero">
          <Description>The derived scaling Scl shall be greater than zero.</Description>
          <Definition> Scl &gt; 0.0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCartesianTransformationOperator2D">
      <WhereRules>
        <WhereRule Name="DimEqual2">
          <Description>The coordinate space dimensionality of this entity shall be 2.</Description>
          <Definition> SELF\IfcCartesianTransformationOperator.Dim = 2</Definition>
        </WhereRule>
        <WhereRule Name="Axis1Is2D">
          <Description>The inherited Axis1 should have (if given) the dimensionality of 2.</Description>
          <Definition> NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis1)) OR 
(SELF\IfcCartesianTransformationOperator.Axis1.Dim = 2)</Definition>
        </WhereRule>
        <WhereRule Name="Axis2Is2D">
          <Description>The inherited Axis2 should have (if given) the dimensionality of 2.</Description>
          <Definition> NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis2)) OR 
(SELF\IfcCartesianTransformationOperator.Axis2.Dim = 2)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCartesianTransformationOperator2DnonUniform">
      <WhereRules>
        <WhereRule Name="Scale2GreaterZero">
          <Description>The derived scaling Scl2 shall be greater than zero.</Description>
          <Definition> Scl2 &gt; 0.0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCartesianTransformationOperator3D">
      <WhereRules>
        <WhereRule Name="DimIs3D">
          <Description>The coordinate space dimensionality of this entity shall be 3.</Description>
          <Definition> SELF\IfcCartesianTransformationOperator.Dim = 3</Definition>
        </WhereRule>
        <WhereRule Name="Axis1Is3D">
          <Description>The inherited Axis1 should have (if given) the dimensionality of 3.</Description>
          <Definition> NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis1)) OR 
(SELF\IfcCartesianTransformationOperator.Axis1.Dim = 3)</Definition>
        </WhereRule>
        <WhereRule Name="Axis2Is3D">
          <Description>The inherited Axis2 should have (if given) the dimensionality of 3.</Description>
          <Definition> NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis2)) OR 
(SELF\IfcCartesianTransformationOperator.Axis2.Dim = 3)</Definition>
        </WhereRule>
        <WhereRule Name="Axis3Is3D">
          <Description>The Axis3 should have (if given) the dimensionality of 3.</Description>
          <Definition> NOT(EXISTS(Axis3)) OR (Axis3.Dim = 3)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCartesianTransformationOperator3DnonUniform">
      <WhereRules>
        <WhereRule Name="Scale2GreaterZero">
          <Description>The derived scaling Scl2 shall be greater than zero.</Description>
          <Definition> Scl2 &gt; 0.0</Definition>
        </WhereRule>
        <WhereRule Name="Scale3GreaterZero">
          <Description>The derived scaling Scl3 shall be greater than zero.</Description>
          <Definition> Scl3 &gt; 0.0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCompositeCurve">
      <WhereRules>
        <WhereRule Name="CurveContinuous">
          <Description>No transition code should be Discontinuous, except for the last code of an open curve.</Description>
          <Definition> ((NOT ClosedCurve) AND (SIZEOF(QUERY(Temp &lt;* Segments | Temp.Transition = Discontinuous)) = 1)) OR ((ClosedCurve) AND (SIZEOF(QUERY(Temp &lt;* Segments | Temp.Transition = Discontinuous)) = 0))</Definition>
        </WhereRule>
        <WhereRule Name="SameDim">
          <Description>Ensures, that all segments used in the curve have the same dimensionality.</Description>
          <Definition> SIZEOF( QUERY( Temp &lt;* Segments | Temp.Dim &lt;&gt; Segments[1].Dim)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCompositeCurveOnSurface">
      <WhereRules>
        <WhereRule Name="SameSurface">
          <Description>The BasisSurface shall contain at least one surface (and exactly one surface). This ensures that all segments reference curves on the same surface.</Description>
          <Definition> SIZEOF(BasisSurface) &gt; 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCompositeCurveSegment">
      <WhereRules>
        <WhereRule Name="ParentIsBoundedCurve">
          <Description>The parent curve shall be a bounded curve.</Description>
          <Definition> ('IFC4.IFCBOUNDEDCURVE' IN TYPEOF(ParentCurve))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDimensionCount">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>The dimension count should be an integer between 1 and 3 NOTE: This is a further constraint by IFC, the upper limit does not exist in STEP.</Description>
          <Definition> { 0 &lt; SELF &lt;= 3 }</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDirection">
      <WhereRules>
        <WhereRule Name="MagnitudeGreaterZero">
          <Description>The magnitude of the direction vector shall be greater than zero.</Description>
          <Definition> SIZEOF(QUERY(Tmp &lt;* DirectionRatios | Tmp &lt;&gt; 0.0)) &gt; 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcIndexedPolyCurve">
      <WhereRules>
        <WhereRule Name="Consecutive">
          <Description>If a list of indexed segments is provided, they need to be consecutive, meaning that the last index of all, but the last, segments shall be identical with the first index of the next segment.</Description>
          <Definition> (SIZEOF(Segments) = 0) OR IfcConsecutiveSegments(Segments)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcLine">
      <WhereRules>
        <WhereRule Name="SameDim">
          <Description>The dimensionality of the Pnt, provided by IfcCartesianPoint, shall be the same as the dimensionality of the Dir, provided by IfcVector.</Description>
          <Definition> Dir.Dim = Pnt.Dim</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcOffsetCurve2D">
      <WhereRules>
        <WhereRule Name="DimIs2D">
          <Description>The underlying curve shall be defined in two-dimensional space.</Description>
          <Definition> BasisCurve.Dim = 2</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcOffsetCurve3D">
      <WhereRules>
        <WhereRule Name="DimIs2D">
          <Description>The underlying curve shall be defined in three-dimensional space.</Description>
          <Definition> BasisCurve.Dim = 3</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPcurve">
      <WhereRules>
        <WhereRule Name="DimIs2D">
          <Description>The dimensionality of the parameter space curve shall be 2.</Description>
          <Definition> ReferenceCurve.Dim = 2</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPolyline">
      <WhereRules>
        <WhereRule Name="SameDim">
          <Description>The space dimensionality of all Points shall be the same.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* Points | Temp.Dim &lt;&gt; Points[1].Dim)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRationalBSplineCurveWithKnots">
      <WhereRules>
        <WhereRule Name="SameNumOfWeightsAndPoints">
          <Description>There shall be the same number of weights as control points.</Description>
          <Definition> SIZEOF(WeightsData) = SIZEOF(SELF\IfcBSplineCurve.ControlPointsList)</Definition>
        </WhereRule>
        <WhereRule Name="WeightsGreaterZero">
          <Description>All the weights shall have values greater than 0.0.</Description>
          <Definition> IfcCurveWeightsPositive(SELF)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRationalBSplineSurfaceWithKnots">
      <WhereRules>
        <WhereRule Name="CorrespondingWeightsDataLists">
          <Description>The array dimensions for the weights shall be consistent with the control points data.</Description>
          <Definition> (SIZEOF(WeightsData) = SIZEOF(SELF\IfcBSplineSurface.ControlPointsList))
AND 
(SIZEOF(WeightsData[1]) = SIZEOF(SELF\IfcBSplineSurface.ControlPointsList[1]))</Definition>
        </WhereRule>
        <WhereRule Name="WeightValuesGreaterZero">
          <Description>The weight value associated with each control point shall be greater than zero.</Description>
          <Definition> IfcSurfaceWeightsPositive(SELF)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRectangularTrimmedSurface">
      <WhereRules>
        <WhereRule Name="U1AndU2Different">
          <Description>U1 and U2 shall have different values.</Description>
          <Definition> U1 &lt;&gt; U2</Definition>
        </WhereRule>
        <WhereRule Name="V1AndV2Different">
          <Description>V1 and V2 shall have different values.</Description>
          <Definition> V1 &lt;&gt; V2</Definition>
        </WhereRule>
        <WhereRule Name="UsenseCompatible">
          <Description>With exception of those surfaces closed in the U parameter, direction Usense shall be compatible with the ordered parameter values for U.</Description>
          <Definition> (('IFC4.IFCELEMENTARYSURFACE' IN TYPEOF(BasisSurface)) AND
         (NOT ('IFC4.IFCPLANE' IN TYPEOF(BasisSurface)))) OR
         ('IFC4.IFCSURFACEOFREVOLUTION' IN TYPEOF(BasisSurface)) OR
         (Usense = (U2 &gt; U1))</Definition>
        </WhereRule>
        <WhereRule Name="VsenseCompatible">
          <Description>Vsense shall be compatible with the ordered parameter values for V.</Description>
          <Definition> Vsense = (V2 &gt; V1)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcReparametrisedCompositeCurveSegment">
      <WhereRules>
        <WhereRule Name="PositiveLengthParameter">
          <Description>The ParamLength shall be greater than zero.</Description>
          <Definition> ParamLength &gt; 0.0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRepresentationMap">
      <WhereRules>
        <WhereRule Name="ApplicableMappedRepr">
          <Description>Only representations of type IfcShapeRepresentation, or IfcTopologyRepresentation are allowed as MappedRepresentation.</Description>
          <Definition> 'IFC4.IFCSHAPEMODEL' IN TYPEOF(MappedRepresentation)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTrimmedCurve">
      <WhereRules>
        <WhereRule Name="Trim1ValuesConsistent">
          <Description>Either a single value is specified for Trim1, or the two trimming values are of different type (point and parameter)</Description>
          <Definition> (HIINDEX(Trim1) = 1) OR (TYPEOF(Trim1[1]) &lt;&gt; TYPEOF(Trim1[2]))</Definition>
        </WhereRule>
        <WhereRule Name="Trim2ValuesConsistent">
          <Description>Either a single value is specified for Trim2, or the two trimming values are of different type (point and parameter)</Description>
          <Definition> (HIINDEX(Trim2) = 1) OR (TYPEOF(Trim2[1]) &lt;&gt; TYPEOF(Trim2[2]))</Definition>
        </WhereRule>
        <WhereRule Name="NoTrimOfBoundedCurves">
          <Description>Already bounded curves shall not be trimmed.</Description>
          <Definition> NOT('IFC4.IFCBOUNDEDCURVE' IN TYPEOF(BasisCurve))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcVector">
      <WhereRules>
        <WhereRule Name="MagGreaterOrEqualZero">
          <Description>The magnitude shall be positive or zero.</Description>
          <Definition> Magnitude &gt;= 0.0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAirTerminal">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcAirTerminalType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcAirTerminalTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcAirTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no air terminal type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcAirTerminalType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCAIRTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAirTerminalBox">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcAirTerminalBoxType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcAirTerminalBoxTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcAirTerminalBoxTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no air terminal box type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcAirTerminalBoxType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCAIRTERMINALBOXTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAirToAirHeatRecovery">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcAirToAirHeatRecoveryType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no air-to-air heat recovery type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcAirToAirHeatRecoveryType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCAIRTOAIRHEATRECOVERYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBoiler">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcBoilerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcBoilerTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcBoilerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no boiler type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcBoilerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCBOILERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBurner">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcBurnerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcBurnerTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcBurnerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no burner type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcBurnerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCBURNERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcChiller">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcChillerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcChillerTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcChillerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no chiller type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcChillerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCHILLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCoil">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCoilType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCoilTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCoilTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no coil type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCoilType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCOILTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCompressor">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCompressorType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCompressorTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCompressorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no compressor type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCompressorType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCOMPRESSORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCondenser">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCondenserType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCondenserTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCondenserTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no condenser type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCondenserType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCONDENSERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCooledBeam">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCooledBeamType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCooledBeamTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCooledBeamTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no cooled beam type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCooledBeamType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCOOLEDBEAMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCoolingTower">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCoolingTowerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCoolingTowerTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCoolingTowerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no cooling tower type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCoolingTowerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCCOOLINGTOWERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDamper">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcDamperType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcDamperTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcDamperTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no damper type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcDamperType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCDAMPERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDuctFitting">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcDuctFittingType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcDuctFittingTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcDuctFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no duct fitting type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcDuctFittingType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCDUCTFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDuctSegment">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcDuctSegmentType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcDuctSegmentTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcDuctSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no duct segment type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcDuctSegmentType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCDUCTSEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDuctSilencer">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcDuctSilencerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcDuctSilencerTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcDuctSilencerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no duct silencer type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcDuctSilencerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCDUCTSILENCERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcEvaporativeCooler">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcEvaporativeCoolerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcEvaporativeCoolerTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcEvaporativeCoolerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no evaporative cooler type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcEvaporativeCoolerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCEVAPORATIVECOOLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcEvaporator">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcEvaporatorType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcEvaporatorTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcEvaporatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no evaporator type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcEvaporatorType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCEVAPORATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFan">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcFanType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcFanTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcFanTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no fan type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcFanType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCFANTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFilter">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcFilterType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcFilterTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcFilterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no filter type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcFilterType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCFILTERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFlowMeter">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcFlowMeterType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcFlowMeterTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcFlowMeterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no flow meter type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcFlowMeterType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCFLOWMETERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcHeatExchanger">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcHeatExchangerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcHeatExchangerTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcHeatExchangerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no heat exchanger type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcHeatExchangerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCHEATEXCHANGERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcHumidifier">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcHumidifierType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcHumidifierTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcHumidifierTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no humidifier type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcHumidifierType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCHUMIDIFIERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPipeFitting">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcPipeFittingType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcPipeFittingTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcPipeFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no pipe fitting type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcPipeFittingType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCPIPEFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPipeSegment">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcPipeSegmentType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcPipeSegmentTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcPipeSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no pipe segment type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcPipeSegmentType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCPIPESEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPump">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcPumpType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcPumpTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcPumpTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no pump type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcPumpType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCPUMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSpaceHeater">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcSpaceHeaterType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcSpaceHeaterTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcSpaceHeaterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no space heater type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcSpaceHeaterType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCSPACEHEATERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTank">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcTankType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcTankTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcTankTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no tank type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcTankType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCTANKTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTubeBundle">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcTubeBundleType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcTubeBundleTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcTubeBundleTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no tube bundle type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcTubeBundleType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCTUBEBUNDLETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcUnitaryEquipment">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcUnitaryEquipmentType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcUnitaryEquipmentTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcUnitaryEquipmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no unitary equipment type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcUnitaryEquipmentType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCUNITARYEQUIPMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcValve">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcValveType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcValveTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcValveTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no valve type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcValveType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCVALVETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcVibrationIsolator">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcVibrationIsolatorType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcVibrationIsolatorTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcVibrationIsolatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no vibration isolator type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcVibrationIsolatorType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCVIBRATIONISOLATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcComplexPropertyTemplate">
      <WhereRules>
        <WhereRule Name="UniquePropertyNames">
          <Description>Every individual IfcPropertyTemplate within the complex property template shall have a unique Name attribute value.</Description>
          <Definition> IfcUniquePropertyTemplateNames(HasPropertyTemplates)</Definition>
        </WhereRule>
        <WhereRule Name="NoSelfReference">
          <Description />
          <Definition> SIZEOF(QUERY(temp &lt;* HasPropertyTemplates | SELF :=: temp)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcProduct">
      <WhereRules>
        <WhereRule Name="PlacementForShapeRepresentation">
          <Description>If a Representation is given being an IfcProductDefinitionShape, then also an ObjectPlacement has to be given. The ObjectPlacement defines the object coordinate system in which the geometric representation items of the IfcProductDefinitionShape are founded. 

NOTE  If the Representation of several subtypes of IfcProduct have the same coordinate system it is permitted to share an instance of IfcObjectPlacement.</Description>
          <Definition> (EXISTS(Representation) AND EXISTS(ObjectPlacement))
            OR (EXISTS(Representation) AND 
			   (SIZEOF(QUERY(temp &lt;* Representation.Representations | 'IFC4.IFCSHAPEREPRESENTATION' IN TYPEOF(temp))) = 0))
            OR (NOT(EXISTS(Representation)))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcProject">
      <WhereRules>
        <WhereRule Name="HasName">
          <Description>The Name attribute has to be provided for IfcProject. It is the short name for the project.</Description>
          <Definition> EXISTS(SELF\IfcRoot.Name)</Definition>
        </WhereRule>
        <WhereRule Name="CorrectContext">
          <Description>If a RepresentationContexts relation is provided then there shall be no instance of IfcGeometricRepresentationSubContext directly included in the set of RepresentationContexts.</Description>
          <Definition> NOT(EXISTS(SELF\IfcContext.RepresentationContexts)) OR
(SIZEOF(QUERY(Temp &lt;* SELF\IfcContext.RepresentationContexts |
 'IFC4.IFCGEOMETRICREPRESENTATIONSUBCONTEXT' IN TYPEOF(Temp)
  )) = 0)</Definition>
        </WhereRule>
        <WhereRule Name="NoDecomposition">
          <Description>The IfcProject represents the root of the any decomposition tree. It shall therefore not be used to decompose any other object definition.</Description>
          <Definition> SIZEOF(SELF\IfcObjectDefinition.Decomposes) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPropertySet">
      <WhereRules>
        <WhereRule Name="ExistsName">
          <Description>The Name attribute has to be provided. The attribute is used to specify the signifier of the property set. The properties that are allowed to be attached to a particular property set may be given within the property set definition part of the IFC specification. Those property set definitions are references in the semantic definition section of the individal subtypes of IfcObjectDefinition.</Description>
          <Definition> EXISTS(SELF\IfcRoot.Name)</Definition>
        </WhereRule>
        <WhereRule Name="UniquePropertyNames">
          <Description>Every individual subtype of IfcProperty within the property set shall have a unique Name attribute value.</Description>
          <Definition> IfcUniquePropertyName(HasProperties)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPropertySetTemplate">
      <WhereRules>
        <WhereRule Name="ExistsName">
          <Description>The Name attribute has to be provided. The attribute is used to specify the signifier of the property set template. The properties that are allowed to be attached to a particular property set template may be given within the property set definition part of the IFC specification.</Description>
          <Definition> EXISTS(SELF\IfcRoot.Name)</Definition>
        </WhereRule>
        <WhereRule Name="UniquePropertyNames">
          <Description>Every individual IfcPropertyTemplate within the property set template shall have a unique Name attribute value.</Description>
          <Definition> IfcUniquePropertyTemplateNames(HasPropertyTemplates)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcProxy">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>The Name attribute has to be provided for a proxy.</Description>
          <Definition> EXISTS(SELF\IfcRoot.Name)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelAggregates">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance to with the relation points as provided by RelatingObject shall not be contained in the set of RelatedObjects.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* RelatedObjects | RelatingObject :=: Temp)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelAssigns">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Rule checks whether the types of the assigned related objects comply with the contraint given by the RelatedObjectsType. The rule is important for constraint checks at subtypes of IfcRelAssigns or at subtypes of IfcObject, which refers to assignment relationships through the inverse HasAssignments relation.</Description>
          <Definition> IfcCorrectObjectAssignment(RelatedObjectsType, RelatedObjects)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelAssignsToActor">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance to with the relation points shall not be contained in the set of RelatedObjects.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* SELF\IfcRelAssigns.RelatedObjects | RelatingActor :=: Temp)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelAssignsToControl">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance to with the relation points shall not be contained in the set of RelatedObjects.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* SELF\IfcRelAssigns.RelatedObjects | RelatingControl :=: Temp)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelAssignsToGroup">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance to with the relation points shall not be contained in the set of RelatedObjects.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* SELF\IfcRelAssigns.RelatedObjects | RelatingGroup :=: Temp)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelAssignsToProcess">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance to with the relation points as provided by RelatingProcess shall not be contained in the set of RelatedObjects.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* SELF\IfcRelAssigns.RelatedObjects | RelatingProcess :=: Temp)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelAssignsToProduct">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance to which the relation points, as provided by RelatingProduct shall not be contained in the set of RelatedObjects.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* SELF\IfcRelAssigns.RelatedObjects | RelatingProduct :=: Temp)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelAssignsToResource">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance to with the relation points shall not be contained in the set of RelatedObjects.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* SELF\IfcRelAssigns.RelatedObjects | RelatingResource :=: Temp)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelDeclares">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance to with the relation points shall not be contained in the set of RelatedObjects.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* RelatedDefinitions | RelatingContext :=: Temp)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelNests">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance to with the relation points as provided by RelatingObject shall not be contained in the list of RelatedObjects.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* RelatedObjects | RelatingObject :=: Temp)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTypeObject">
      <WhereRules>
        <WhereRule Name="NameRequired">
          <Description>A Name attribute has to be provided. The name can be declared within the IFC specification as part of the property set agreements.</Description>
          <Definition> EXISTS(SELF\IfcRoot.Name)</Definition>
        </WhereRule>
        <WhereRule Name="UniquePropertySetNames">
          <Description />
          <Definition> (NOT(EXISTS(HasPropertySets))) OR IfcUniquePropertySetNames(HasPropertySets)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTypeProduct">
      <WhereRules>
        <WhereRule Name="ApplicableOccurrence">
          <Description>The product type (or style), if assigned to an object, shall only be assigned to object being a sub type of IfcProduct.</Description>
          <Definition> NOT(EXISTS(SELF\IfcTypeObject.Types[1])) OR
(SIZEOF(QUERY(temp &lt;* SELF\IfcTypeObject.Types[1].RelatedObjects |
  NOT('IFC4.IFCPRODUCT' IN TYPEOF(temp)))
) = 0)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCardinalPointReference">
      <WhereRules>
        <WhereRule Name="GreaterThanZero">
          <Description>Cardinal point reference shall be greater than zero.</Description>
          <Definition> SELF &gt; 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcMaterialLayer">
      <WhereRules>
        <WhereRule Name="NormalizedPriority">
          <Description>The Property shall all be given as a normalized integer range [0..100], where 0 is the lowest and 100 the highest priority of the material layer.</Description>
          <Definition> NOT(EXISTS(Priority)) OR {0 &lt;= Priority &lt;= 100}</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcMaterialProfile">
      <WhereRules>
        <WhereRule Name="NormalizedPriority">
          <Description>The Property shall all be given as a normalized integer range [0..100], where 0 is the lowest and 100 the highest priority of the material profile.</Description>
          <Definition> NOT(EXISTS(Priority)) OR {0 &lt;= Priority &lt;= 100}</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCompoundPlaneAngleMeasure">
      <WhereRules>
        <WhereRule Name="MinutesInRange">
          <Description>The second measure (minutes) shall be between -60 exclusive and 60 exclusive.</Description>
          <Definition> ABS(SELF[2]) &lt; 60</Definition>
        </WhereRule>
        <WhereRule Name="SecondsInRange">
          <Description>The third measure (seconds) shall be between -60 exclusive and 60 exclusive.</Description>
          <Definition> ABS(SELF[3]) &lt; 60</Definition>
        </WhereRule>
        <WhereRule Name="MicrosecondsInRange">
          <Description>The forth measure (millionth-seconds), if asserted, shall be between -1e6 exclusive and 1e6 exclusive.</Description>
          <Definition> (SIZEOF(SELF) = 3) OR (ABS(SELF[4]) &lt; 1000000)</Definition>
        </WhereRule>
        <WhereRule Name="ConsistentSign">
          <Description>All non-zero measure components shall have the same sign (positive or negative).</Description>
          <Definition> ((SELF[1] &gt;= 0) AND (SELF[2] &gt;= 0) AND (SELF[3] &gt;= 0) AND ((SIZEOF(SELF) = 3) OR (SELF[4] &gt;= 0)))
OR
((SELF[1] &lt;= 0) AND (SELF[2] &lt;= 0) AND (SELF[3] &lt;= 0) AND ((SIZEOF(SELF) = 3) OR (SELF[4] &lt;= 0)))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDerivedUnit">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Units as such shall not be re-defined as derived units.</Description>
          <Definition> (SIZEOF (Elements) &gt; 1) OR ((SIZEOF (Elements) = 1) AND (Elements[1].Exponent &lt;&gt; 1 ))</Definition>
        </WhereRule>
        <WhereRule Name="WR2">
          <Description>When attribute UnitType has enumeration value USERDEFINED then attribute UserDefinedType shall also have a value.</Description>
          <Definition> (UnitType &lt;&gt; IfcDerivedUnitEnum.USERDEFINED) OR
((UnitType = IfcDerivedUnitEnum.USERDEFINED) AND 
 (EXISTS(SELF.UserDefinedType)))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcHeatingValueMeasure">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description />
          <Definition> SELF &gt; 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcNamedUnit">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Correct dimensions of the unit are established through the function IfcCorrectDimensions.</Description>
          <Definition> IfcCorrectDimensions (SELF.UnitType, SELF.Dimensions)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcNonNegativeLengthMeasure">
      <WhereRules>
        <WhereRule Name="NotNegative">
          <Description>A non-negative measure shall be greater than or equal to zero.</Description>
          <Definition> SELF &gt;= 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcNormalisedRatioMeasure">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Normalized ratio shall be a non-negative value less than or equal to 1.0</Description>
          <Definition> {0.0 &lt;= SELF &lt;= 1.0}</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPHMeasure">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>The pH value shall be in the range from 0 to 14.</Description>
          <Definition> {0.0 &lt;= SELF &lt;= 14.0}</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPositiveInteger">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>A positive integer shall be greater than zero.</Description>
          <Definition> SELF &gt; 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPositiveLengthMeasure">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>A positive measure shall be greater than zero.</Description>
          <Definition> SELF &gt; 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPositivePlaneAngleMeasure">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>A positive measure shall be greater than zero.</Description>
          <Definition> SELF &gt; 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPositiveRatioMeasure">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>A positive measure shall be greater than zero.</Description>
          <Definition> SELF &gt; 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcUnitAssignment">
      <WhereRules>
        <WhereRule Name="WR01">
          <Description>Checks that the set of globally assigned units has each unit type (either of type IfcNamedUnit,IfcDerivedUnit, or IfcMonetaryUnit) defined only once.</Description>
          <Definition> IfcCorrectUnitAssignment(Units)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFireSuppressionTerminal">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description />
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcFireSuppressionTerminalTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcFireSuppressionTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no fires suppression terminal type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcFireSuppressionTerminalType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCFIRESUPPRESSIONTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSanitaryTerminal">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description />
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcSanitaryTerminalTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcSanitaryTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no sanitary terminal type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcSanitaryTerminalType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCSANITARYTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStackTerminal">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description />
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcStackTerminalTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcStackTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no stack terminal type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcStackTerminalType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCSTACKTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWasteTerminal">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description />
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcWasteTerminalTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcWasteTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no waste terminal type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcWasteTerminalType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR 
  ('IFC4.IFCWASTETERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBlobTexture">
      <WhereRules>
        <WhereRule Name="SupportedRasterFormat">
          <Description>Currently the formats of bmp, jpg, gif and pgn, shall be supported.</Description>
          <Definition> SELF.RasterFormat IN ['BMP', 'JPG', 'GIF', 'PNG']</Definition>
        </WhereRule>
        <WhereRule Name="RasterCodeByteStream">
          <Description>The size of the raster code shall be a multiple of 8 bits.</Description>
          <Definition> BLENGTH(RasterCode) MOD 8 = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCurveStyle">
      <WhereRules>
        <WhereRule Name="MeasureOfWidth">
          <Description>The curve width, if provided, shall be given by an IfcPositiveLengthMeasure representing the curve width in the default measure unit, or by an IfcDescriptiveMeasure with the value 'by layer' representing the curve width by the default curve width at the associated layer.</Description>
          <Definition> (NOT(EXISTS(CurveWidth))) OR
('IFC4.IFCPOSITIVELENGTHMEASURE' IN TYPEOF(CurveWidth)) OR 
 (('IFC4.IFCDESCRIPTIVEMEASURE' IN TYPEOF(CurveWidth)) AND
 (CurveWidth = 'by layer'))</Definition>
        </WhereRule>
        <WhereRule Name="IdentifiableCurveStyle">
          <Description>At minimum one of the three attribute values have to be provided, CurveFont, CurveWidth, CurveColour.</Description>
          <Definition> EXISTS(CurveFont) OR EXISTS(CurveWidth) OR EXISTS(CurveColour)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCurveStyleFontPattern">
      <WhereRules>
        <WhereRule Name="VisibleLengthGreaterEqualZero">
          <Description>The value of a visible pattern length shall be equal or greater then zero.</Description>
          <Definition> VisibleSegmentLength &gt;= 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDraughtingPreDefinedColour">
      <WhereRules>
        <WhereRule Name="PreDefinedColourNames">
          <Description>The inherited name for pre defined items shall only have the value of one of the following words.</Description>
          <Definition> SELF\IfcPreDefinedItem.Name IN ['black','red','green','blue','yellow',
     'magenta','cyan','white','by layer']</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDraughtingPreDefinedCurveFont">
      <WhereRules>
        <WhereRule Name="PreDefinedCurveFontNames">
          <Description>The name of the IfcDraughtingPreDefinedCurveFont shall be 'continuous', 'chain', 'chain double dash', 'dashed', 'dotted' or 'by layer'.</Description>
          <Definition> SELF\IfcPredefinedItem.Name IN
       ['continuous',
        'chain',
        'chain double dash',
        'dashed',
        'dotted',
        'by layer']</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFillAreaStyle">
      <WhereRules>
        <WhereRule Name="MaxOneColour">
          <Description>There shall be a maximum of one colour assignment to the fill area style.</Description>
          <Definition> SIZEOF(QUERY(Style &lt;* SELF.FillStyles |
  'IFC4.IFCCOLOUR' IN
   TYPEOF(Style)
  )) &lt;= 1</Definition>
        </WhereRule>
        <WhereRule Name="MaxOneExtHatchStyle">
          <Description>There shall be a maximum of one externally defined hatch style assignment to the fill area style.</Description>
          <Definition> SIZEOF(QUERY(Style &lt;* SELF.FillStyles |
  'IFC4.IFCEXTERNALLYDEFINEDHATCHSTYLE' IN
   TYPEOF(Style)
  )) &lt;= 1</Definition>
        </WhereRule>
        <WhereRule Name="ConsistentHatchStyleDef">
          <Description>Either the fill area style contains a definition from an externally defined hatch style, or from (one or many) fill area style hatchings or from (one or many) fill area style tiles, but not a combination of those three types.</Description>
          <Definition> IfcCorrectFillAreaStyle(SELF.FillStyles)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFillAreaStyleHatching">
      <WhereRules>
        <WhereRule Name="PatternStart2D">
          <Description>The IfcCartesianPoint, if given as value to PatternStart shall have the dimensionality of 2.</Description>
          <Definition> NOT(EXISTS(PatternStart)) OR (PatternStart.Dim = 2)</Definition>
        </WhereRule>
        <WhereRule Name="RefHatchLine2D">
          <Description>The IfcCartesianPoint, if given as value to PointOfReferenceHatchLine shall have the dimensionality of 2.</Description>
          <Definition> NOT(EXISTS(PointOfReferenceHatchLine)) OR (PointOfReferenceHatchLine.Dim = 2)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFontStyle">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Allowable values for font style.</Description>
          <Definition> SELF IN ['normal','italic','oblique']</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFontVariant">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description />
          <Definition> SELF IN ['normal','small-caps']</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFontWeight">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description />
          <Definition> SELF IN ['normal','small-caps','100','200','300','400','500','600','700','800','900']</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPixelTexture">
      <WhereRules>
        <WhereRule Name="MinPixelInS">
          <Description>The minimum number of pixel in width (S coordinate) direction shall be 1.</Description>
          <Definition> Width &gt;= 1</Definition>
        </WhereRule>
        <WhereRule Name="MinPixelInT">
          <Description>The minimum number of pixel in height (T coordinate) direction shall be 1.</Description>
          <Definition> Height &gt;= 1</Definition>
        </WhereRule>
        <WhereRule Name="NumberOfColours">
          <Description>The number of color components shall be either 1, 2, 3, or 4.</Description>
          <Definition> {1 &lt;= ColourComponents &lt;= 4}</Definition>
        </WhereRule>
        <WhereRule Name="SizeOfPixelList">
          <Description>The list of pixel shall have exactly width*height members.</Description>
          <Definition> SIZEOF(Pixel) = (Width * Height)</Definition>
        </WhereRule>
        <WhereRule Name="PixelAsByteAndSameLength">
          <Description>The binary value provided for each Pixel shall be a multiple of 8 bits. And all pixel shall have the same binary length.</Description>
          <Definition> SIZEOF(QUERY(temp&lt;* Pixel |
 (BLENGTH(temp) MOD 8 = 0) AND
 (BLENGTH(temp) = BLENGTH(Pixel[1]))
)) = SIZEOF(Pixel)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSpecularRoughness">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Specular roughness shall be given as a non-negative value less than or equal to 1.0</Description>
          <Definition> {0.0 &lt;= SELF &lt;= 1.0}</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStyledItem">
      <WhereRules>
        <WhereRule Name="ApplicableItem">
          <Description>A styled item cannot be styled by another styled item.</Description>
          <Definition> NOT('IFC4.IFCSTYLEDITEM' IN TYPEOF(Item))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSurfaceStyle">
      <WhereRules>
        <WhereRule Name="MaxOneShading">
          <Description>The IfcSurfaceStyleShading shall only be used zero or one time within the set of Styles.</Description>
          <Definition> SIZEOF(QUERY(Style &lt;* SELF.Styles |
  'IFC4.IFCSURFACESTYLESHADING' IN
   TYPEOF(Style)
  )) &lt;= 1</Definition>
        </WhereRule>
        <WhereRule Name="MaxOneLighting">
          <Description>The IfcSurfaceStyleLighting shall only be used zero or one time within the set of Styles.</Description>
          <Definition> SIZEOF(QUERY(Style &lt;* SELF.Styles |
  'IFC4.IFCSURFACESTYLELIGHTING' IN
   TYPEOF(Style)
  )) &lt;= 1</Definition>
        </WhereRule>
        <WhereRule Name="MaxOneRefraction">
          <Description>The IfcSurfaceStyleRefraction shall only be used zero or one time within the set of Styles.</Description>
          <Definition> SIZEOF(QUERY(Style &lt;* SELF.Styles |
  'IFC4.IFCSURFACESTYLEREFRACTION' IN
   TYPEOF(Style)
  )) &lt;= 1</Definition>
        </WhereRule>
        <WhereRule Name="MaxOneTextures">
          <Description>The IfcSurfaceStyleWithTextures shall only be used zero or one time within the set of Styles.</Description>
          <Definition> SIZEOF(QUERY(Style &lt;* SELF.Styles |
  'IFC4.IFCSURFACESTYLEWITHTEXTURES' IN
   TYPEOF(Style)
  )) &lt;= 1</Definition>
        </WhereRule>
        <WhereRule Name="MaxOneExtDefined">
          <Description>The IfcExternallyDefinedSurfaceStyle shall only be used zero or one time within the set of Styles.</Description>
          <Definition> SIZEOF(QUERY(Style &lt;* SELF.Styles |
  'IFC4.IFCEXTERNALLYDEFINEDSURFACESTYLE' IN
   TYPEOF(Style)
  )) &lt;= 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTextAlignment">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Allowable values for text alignment.</Description>
          <Definition> SELF IN ['left', 'right', 'center', 'justify']</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTextDecoration">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Allowable values for text decoration.</Description>
          <Definition> SELF IN ['none', 'underline', 'overline', 'line-through', 'blink']</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTextStyleFontModel">
      <WhereRules>
        <WhereRule Name="MeasureOfFontSize">
          <Description>The size should be given by a positive length measure,</Description>
          <Definition> ('IFC4.IFCLENGTHMEASURE' IN TYPEOF(SELF.FontSize)) AND
(SELF.FontSize &gt; 0.)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTextTransformation">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Allowable values for text transform.</Description>
          <Definition> SELF IN ['capitalize', 'uppercase', 'lowercase', 'none']</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBoxAlignment">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description />
          <Definition> SELF IN ['top-left', 'top-middle', 'top-right', 'middle-left', 'center', 'middle-right', 'bottom-left', 'bottom-middle', 'bottom-right']</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTextLiteralWithExtent">
      <WhereRules>
        <WhereRule Name="WR31">
          <Description>The subtype of IfcPlanarExtent, IfcPlanarBox, should not be used to represent an Extent for the text literal.</Description>
          <Definition> NOT('IFC4.IFCPLANARBOX' IN TYPEOF(Extent))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPresentationLayerAssignment">
      <WhereRules>
        <WhereRule Name="ApplicableItems">
          <Description>The items within the set of AssignedItems that can be assigned to a presentation layer shall be geometric shape representation or representation items.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* AssignedItems | (
  SIZEOF(TYPEOF(temp) * [
    'IFC4.IFCSHAPEREPRESENTATION',
    'IFC4.IFCGEOMETRICREPRESENTATIONITEM',
    'IFC4.IFCMAPPEDITEM']) = 1)
)) = SIZEOF(AssignedItems)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPresentationLayerWithStyle">
      <WhereRules>
        <WhereRule Name="ApplicableOnlyToItems">
          <Description>The IfcPresentationLayerWithStyle shall only be used to assign subtypes of IfcGeometricRepresentationItem's and to IfcMappedItem. There shall be no instance of subtypes of IfcRepresentation in the set of AssignedItem's.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* AssignedItems | (
  SIZEOF(TYPEOF(temp) * [
    'IFC4.IFCGEOMETRICREPRESENTATIONITEM',
    'IFC4.IFCMAPPEDITEM']) = 1)
)) = SIZEOF(AssignedItems)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcEvent">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset, or the inherited attribute ObjectType must be asserted when the value of PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR (PredefinedType &lt;&gt; IfcEventTypeEnum.USERDEFINED) OR ((PredefinedType = IfcEventTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either the EventTriggerType attribute is unset, or the attribute UserDefinedEventTriggerType must be asserted when the value of EventTriggerType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(EventTriggerType)) OR (EventTriggerType &lt;&gt; IfcEventTriggerTypeEnum.USERDEFINED) OR ((EventTriggerType = IfcEventTriggerTypeEnum.USERDEFINED) AND EXISTS(UserDefinedEventTriggerType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcEventType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The attribute ProcessType must be asserted when the value of PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcEventTypeEnum.USERDEFINED) OR ((PredefinedType = IfcEventTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectEventTriggerType">
          <Description>The attribute UserDefinedEventTriggerType must be asserted when the value of EventTriggerType is set to USERDEFINED.</Description>
          <Definition> (EventTriggerType &lt;&gt; IfcEventTriggerTypeEnum.USERDEFINED) OR ((EventTriggerType = IfcEventTriggerTypeEnum.USERDEFINED) AND EXISTS(UserDefinedEventTriggerType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcProcedure">
      <WhereRules>
        <WhereRule Name="HasName">
          <Description>The Name attribute should be inserted to describe the task name.</Description>
          <Definition> EXISTS(SELF\IfcRoot.Name)</Definition>
        </WhereRule>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset, or the inherited attribute ObjectType must be asserted when the value of PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR (PredefinedType &lt;&gt; IfcProcedureTypeEnum.USERDEFINED) OR
((PredefinedType = IfcProcedureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcProcedureType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The attribute ProcessType must be asserted when the value of PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcProcedureTypeEnum.USERDEFINED) OR ((PredefinedType = IfcProcedureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelSequence">
      <WhereRules>
        <WhereRule Name="AvoidInconsistentSequence">
          <Description>The RelatingProcess shall not point to the same instance as the RelatedProcess.</Description>
          <Definition> RelatingProcess :&lt;&gt;: RelatedProcess</Definition>
        </WhereRule>
        <WhereRule Name="CorrectSequenceType">
          <Description>The attribute UserDefinedSequenceType must be asserted when the value of SequenceType is set to USERDEFINED.</Description>
          <Definition> (SequenceType &lt;&gt; IfcSequenceEnum.USERDEFINED) OR ((SequenceType = IfcSequenceEnum.USERDEFINED) AND EXISTS(UserDefinedSequenceType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTask">
      <WhereRules>
        <WhereRule Name="HasName">
          <Description>The Name attribute should be inserted to describe the task name.</Description>
          <Definition> EXISTS(SELF\IfcRoot.Name)</Definition>
        </WhereRule>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The attribute ObjectType must be asserted when the value of PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR (PredefinedType &lt;&gt; IfcTaskTypeEnum.USERDEFINED) OR ((PredefinedType = IfcTaskTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTaskType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The attribute ProcessType must be asserted when the value of PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcTaskTypeEnum.USERDEFINED) OR ((PredefinedType = IfcTaskTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWorkCalendar">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The attribute ObjectType must be asserted when the value of the IfcWorkCalendarTypeEnum is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR (PredefinedType &lt;&gt; IfcWorkCalendarTypeEnum.USERDEFINED) OR
((PredefinedType = IfcWorkCalendarTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWorkPlan">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The attribute ObjectType must be asserted when the value of the IfcWorkPlanTypeEnum is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR (PredefinedType &lt;&gt; IfcWorkPlanTypeEnum.USERDEFINED) OR
((PredefinedType = IfcWorkPlanTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWorkSchedule">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The attribute ObjectType must be asserted when the value of the IfcWorkScheduleTypeEnum is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR (PredefinedType &lt;&gt; IfcWorkScheduleTypeEnum.USERDEFINED) OR
((PredefinedType = IfcWorkScheduleTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBuildingElement">
      <WhereRules>
        <WhereRule Name="MaxOneMaterialAssociation">
          <Description>There should be only a maximum of one material association assigned to an building element. 

NOTE  The material association can assign a single material, a set of materials, a set of material layers, or a set of material profiles by a single association relationship. 

FC2x4 CHANGE The where rule has been promoted from the subtype IfcWall.</Description>
          <Definition> SIZEOF (QUERY(temp &lt;* SELF\IfcObjectDefinition.HasAssociations |
  'IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)
  )) &lt;= 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcElementAssembly">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcElementAssemblyType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcElementAssemblyTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcElementAssemblyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no element assembly type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcElementAssemblyType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCELEMENTASSEMBLYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcElementAssemblyType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcElementAssemblyTypeEnum.USERDEFINED) OR 
((PredefinedType = IfcElementAssemblyTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcElementQuantity">
      <WhereRules>
        <WhereRule Name="UniqueQuantityNames">
          <Description>Every individual IfcPhysicalQuantity within the set Quantities shall have a unique Name attribute value.</Description>
          <Definition> IfcUniqueQuantityNames(Quantities)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFeatureElementSubtraction">
      <WhereRules>
        <WhereRule Name="HasNoSubtraction">
          <Description>An feature subtraction (e.g. an opening element) can not have other openings to void itself. The inverse relationship HasOpenings shall therefore be NIL.</Description>
          <Definition> SIZEOF(SELF\IfcElement.HasOpenings) = 0</Definition>
        </WhereRule>
        <WhereRule Name="IsNotFilling">
          <Description>An feature subtraction (e.g. an opening element) can not be a filling of another void. The inverse relationship FillsVoids shall therefore be NIL.</Description>
          <Definition> SIZEOF(SELF\IfcElement.FillsVoids) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcGeographicElement">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the IfcGeographicElement attribute is unset (e.g. because an IfcGeographicElementType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcGeographicElementTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcGeographicElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no geographic element type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcGeographicElementType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCGEOGRAPHICELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcGeographicElementType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcGeographicElementTypeEnum.USERDEFINED) OR
((PredefinedType = IfcGeographicElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcGrid">
      <WhereRules>
        <WhereRule Name="HasPlacement">
          <Description>The placement for the grid has to be given.</Description>
          <Definition> EXISTS(SELF\IfcProduct.ObjectPlacement)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelAssociatesMaterial">
      <WhereRules>
        <WhereRule Name="NoVoidElement">
          <Description>The material information must not be associated to a substraction feature (such as an opening) or to a virtual element.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* SELF\IfcRelAssociates.RelatedObjects | 
  ('IFC4.IFCFEATUREELEMENTSUBTRACTION' IN TYPEOF(temp)) OR 
  ('IFC4.IFCVIRTUALELEMENT' IN TYPEOF(temp)) 
)) = 0</Definition>
        </WhereRule>
        <WhereRule Name="AllowedElements">
          <Description>The material information, using IfcMaterialSelect should be associated to an element occurrence (including structural members) or an element type (including the door and window styles). Also port can have assigned materials, here indicating the fluid flowing from the port.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* SELF\IfcRelAssociates.RelatedObjects | (
  SIZEOF(TYPEOF(temp) * [   
    'IFC4.IFCELEMENT', 
    'IFC4.IFCELEMENTTYPE',
    'IFC4.IFCWINDOWSTYLE',
    'IFC4.IFCDOORSTYLE',
    'IFC4.IFCSTRUCTURALMEMBER',
    'IFC4.IFCPORT']) = 0) 
)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelConnectsElements">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance of the RelatingElement shall not be the same instance as the RelatedElement.</Description>
          <Definition> RelatingElement :&lt;&gt;: RelatedElement</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelConnectsPorts">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The instance of the RelatingPort shall not be the same instance as the RelatedPort.</Description>
          <Definition> RelatingPort :&lt;&gt;: RelatedPort</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelContainedInSpatialStructure">
      <WhereRules>
        <WhereRule Name="WR31">
          <Description>The relationship object shall not be used to include other spatial structure elements into a spatial structure element. The hierarchy of the spatial structure is defined using IfcRelAggregates.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* RelatedElements | 'IFC4.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF(temp))) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelInterferesElements">
      <WhereRules>
        <WhereRule Name="NotSelfReference">
          <Description>The instance of the RelatingElement shall not be the same instance as the RelatedElement.</Description>
          <Definition> RelatingElement :&lt;&gt;: RelatedElement</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelReferencedInSpatialStructure">
      <WhereRules>
        <WhereRule Name="WR31">
          <Description>The relationship object shall not be used to include other spatial structure elements into a spatial structure element. The hierarchy of the spatial structure is defined using IfcRelAggregates.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* RelatedElements | 'IFC4.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF(temp))) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelSpaceBoundary">
      <WhereRules>
        <WhereRule Name="CorrectPhysOrVirt">
          <Description>If the space boundary is physical, it shall be provided by an element (i.e. excluding a virtual element). If the space boundary is virtual, it shall either have a virtual element or an opening providing the space boundary. If the space boundary PhysicalOrVirtualBoundary attribute is not defined, no restrictions are imposed.</Description>
          <Definition> ((PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.Physical) 
  AND (NOT('IFC4.IFCVIRTUALELEMENT' IN TYPEOF(RelatedBuildingElement)))) 
OR 
((PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.Virtual) 
  AND (('IFC4.IFCVIRTUALELEMENT' IN TYPEOF(RelatedBuildingElement)) 
  OR   ('IFC4.IFCOPENINGELEMENT' IN TYPEOF(RelatedBuildingElement)))) 
OR 
(PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.NotDefined)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSpace">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcSpaceType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcSpaceTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcSpaceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no space type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcSpaceType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCSPACETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSpaceType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcSpaceTypeEnum.USERDEFINED) OR 
((PredefinedType = IfcSpaceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcSpatialElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSpatialStructureElement">
      <WhereRules>
        <WhereRule Name="WR41">
          <Description>All spatial structure elements shall be associated (using the IfcRelAggregates relationship) with another spatial structure element, or with IfcProject.</Description>
          <Definition> (HIINDEX(SELF\IfcObjectDefinition.Decomposes) = 1) 
AND
('IFC4.IFCRELAGGREGATES' IN TYPEOF(SELF\IfcObjectDefinition.Decomposes[1])) 
AND
(('IFC4.IFCPROJECT' IN TYPEOF (SELF\IfcObjectDefinition.Decomposes[1].RelatingObject)) OR
 ('IFC4.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF (SELF\IfcObjectDefinition.Decomposes[1].RelatingObject))
)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSpatialZone">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcSpatialZoneType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcSpatialZoneTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcSpatialZoneTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no spatial zone type object associated, then the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcSpatialZoneType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCSPATIALZONETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSpatialZoneType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcSpatialZoneTypeEnum.USERDEFINED) OR 
((PredefinedType = IfcSpatialZoneTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcSpatialElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTransportElement">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the IfcTransportElement attribute is unset (e.g. because an IfcTransportElementType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcTransportElementTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcTransportElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no transport element type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcTransportElementType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCTRANSPORTELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTransportElementType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcTransportElementTypeEnum.USERDEFINED) OR
((PredefinedType = IfcTransportElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcZone">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>An IfcZone is grouped by the objectified relationship IfcRelAssignsToGroup. Only objects of type IfcSpace, IfcZone and IfcSpatialZone are allowed as RelatedObjects.</Description>
          <Definition> (SIZEOF(SELF\IfcGroup.IsGroupedBy) = 0) OR
	(SIZEOF (QUERY (temp &lt;* SELF\IfcGroup.IsGroupedBy[1].RelatedObjects |  
		NOT(('IFC4.IFCZONE' IN TYPEOF(temp)) OR 
		('IFC4.IFCSPACE' IN TYPEOF(temp)) OR
		('IFC4.IFCSPATIALZONE' IN TYPEOF(temp))
	))) = 0)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcArbitraryClosedProfileDef">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>The curve used for the outer curve definition shall have the dimensionality of 2.</Description>
          <Definition> OuterCurve.Dim = 2</Definition>
        </WhereRule>
        <WhereRule Name="WR2">
          <Description>The outer curve shall not be of type IfcLine as IfcLine is not a closed curve.</Description>
          <Definition> NOT('IFC4.IFCLINE' IN TYPEOF(OuterCurve))</Definition>
        </WhereRule>
        <WhereRule Name="WR3">
          <Description>The outer curve shall not be of type IfcOffsetCurve2D as it should not be defined as an offset of another curve.</Description>
          <Definition> NOT('IFC4.IFCOFFSETCURVE2D' IN TYPEOF(OuterCurve))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcArbitraryOpenProfileDef">
      <WhereRules>
        <WhereRule Name="WR11">
          <Description>The profile type is a .CURVE., an open profile can only be used to define a swept surface. 

Note  This does not apply to the subtype IfcCentreLineProfileDef.</Description>
          <Definition> ('IFC4.IFCCENTERLINEPROFILEDEF' IN TYPEOF(SELF)) OR 
 (SELF\IfcProfileDef.ProfileType = IfcProfileTypeEnum.CURVE)</Definition>
        </WhereRule>
        <WhereRule Name="WR12">
          <Description>The dimensionality of the curve shall be 2.</Description>
          <Definition> Curve.Dim = 2</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcArbitraryProfileDefWithVoids">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>The type of the profile shall be AREA, as it can only be involved in the definition of a swept area.</Description>
          <Definition> SELF\IfcProfileDef.ProfileType = AREA</Definition>
        </WhereRule>
        <WhereRule Name="WR2">
          <Description>All inner curves shall have the dimensionality of 2.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* InnerCurves | temp.Dim &lt;&gt; 2)) = 0</Definition>
        </WhereRule>
        <WhereRule Name="WR3">
          <Description>None of the inner curves shall by of type IfcLine, as an IfcLine can not be a closed curve.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* InnerCurves | 'IFC4.IFCLINE' IN TYPEOF(temp))) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAsymmetricIShapeProfileDef">
      <WhereRules>
        <WhereRule Name="ValidFlangeThickness">
          <Description>The sum of flange thicknesses shall be less than the overall depth.</Description>
          <Definition> NOT(EXISTS(TopFlangeThickness)) OR ((BottomFlangeThickness + TopFlangeThickness) &lt; OverallDepth)</Definition>
        </WhereRule>
        <WhereRule Name="ValidWebThickness">
          <Description>The web thickness shall be less than either flange width.</Description>
          <Definition> (WebThickness &lt; BottomFlangeWidth) AND (WebThickness &lt; TopFlangeWidth)</Definition>
        </WhereRule>
        <WhereRule Name="ValidBottomFilletRadius">
          <Description>The bottom fillet radius, if given, shall be within the range of allowed values.</Description>
          <Definition> (NOT(EXISTS(BottomFlangeFilletRadius))) OR 
(BottomFlangeFilletRadius &lt;= (BottomFlangeWidth - WebThickness)/2.)</Definition>
        </WhereRule>
        <WhereRule Name="ValidTopFilletRadius">
          <Description>The top fillet radius, if given, shall be within the range of allowed values.</Description>
          <Definition> (NOT(EXISTS(TopFlangeFilletRadius))) OR 
(TopFlangeFilletRadius &lt;= (TopFlangeWidth - WebThickness)/2.)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCircleHollowProfileDef">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>The wall thickness shall be smaller then the radius.</Description>
          <Definition> WallThickness &lt; SELF\IfcCircleProfileDef.Radius</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCompositeProfileDef">
      <WhereRules>
        <WhereRule Name="InvariantProfileType">
          <Description>Either all profiles are areas or all profiles are curves.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* Profiles | temp.ProfileType &lt;&gt; Profiles[1].ProfileType)) = 0</Definition>
        </WhereRule>
        <WhereRule Name="NoRecursion">
          <Description>A composite profile should not include another composite profile, i.e. no recursive definitions should be allowed.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* Profiles | 'IFC4.IFCCOMPOSITEPROFILEDEF' IN TYPEOF(temp))) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCShapeProfileDef">
      <WhereRules>
        <WhereRule Name="ValidGirth">
          <Description>The girth shall be smaller than half of the depth.</Description>
          <Definition> Girth &lt; (Depth / 2.)</Definition>
        </WhereRule>
        <WhereRule Name="ValidInternalFilletRadius">
          <Description>If the value for InternalFilletRadius is given, it shall be small enough to fit into the inner space.</Description>
          <Definition> NOT(EXISTS(InternalFilletRadius)) OR
((InternalFilletRadius &lt;= Width/2. - WallThickness) AND (InternalFilletRadius &lt;= Depth/2. - WallThickness))</Definition>
        </WhereRule>
        <WhereRule Name="ValidWallThickness">
          <Description>The WallThickness shall be smaller than half of the Width and half of the Depth.</Description>
          <Definition> (WallThickness &lt; Width/2.) AND (WallThickness &lt; Depth/2.)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDerivedProfileDef">
      <WhereRules>
        <WhereRule Name="InvariantProfileType">
          <Description>The profile type of the derived profile shall be the same as the type of the parent profile, i.e. both shall be either AREA or CURVE.</Description>
          <Definition> SELF\IfcProfileDef.ProfileType = ParentProfile.ProfileType</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcIShapeProfileDef">
      <WhereRules>
        <WhereRule Name="ValidFlangeThickness">
          <Description>The sum of flange thicknesses shall be less than the overall depth.</Description>
          <Definition> (2. * FlangeThickness) &lt; OverallDepth</Definition>
        </WhereRule>
        <WhereRule Name="ValidWebThickness">
          <Description>The web thickness shall be less then the flange width.</Description>
          <Definition> WebThickness &lt; OverallWidth</Definition>
        </WhereRule>
        <WhereRule Name="ValidFilletRadius">
          <Description>The FilletRadius, if given, shall be within the range of allowed values.</Description>
          <Definition> NOT(EXISTS(FilletRadius)) OR
((FilletRadius &lt;= (OverallWidth - WebThickness)/2.) AND 
 (FilletRadius &lt;= (OverallDepth - (2. * FlangeThickness))/2.))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcLShapeProfileDef">
      <WhereRules>
        <WhereRule Name="ValidThickness">
          <Description>The thickness shall be smaller than the depth and width.</Description>
          <Definition> (Thickness &lt; Depth) AND (NOT(EXISTS(Width)) OR (Thickness &lt; Width))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRectangleHollowProfileDef">
      <WhereRules>
        <WhereRule Name="ValidWallThickness">
          <Description>The wall thickness shall be smaller than half of the X and Y dimension of the rectangle.</Description>
          <Definition> (WallThickness &lt; (SELF\IfcRectangleProfileDef.XDim/2.)) AND 
(WallThickness &lt; (SELF\IfcRectangleProfileDef.YDim/2.))</Definition>
        </WhereRule>
        <WhereRule Name="ValidInnerRadius">
          <Description>The inner fillet radius (if given) shall be small enough to fit into the void.</Description>
          <Definition> NOT(EXISTS(InnerFilletRadius)) OR 
((InnerFilletRadius &lt;= (SELF\IfcRectangleProfileDef.XDim/2. - WallThickness)) AND 
 (InnerFilletRadius &lt;= (SELF\IfcRectangleProfileDef.YDim/2. - WallThickness)))</Definition>
        </WhereRule>
        <WhereRule Name="ValidOuterRadius">
          <Description>The outer fillet radius (if given) shall be small enough to fit into the bounding box.</Description>
          <Definition> NOT(EXISTS(OuterFilletRadius)) OR 
((OuterFilletRadius &lt;= (SELF\IfcRectangleProfileDef.XDim/2.)) AND 
 (OuterFilletRadius &lt;= (SELF\IfcRectangleProfileDef.YDim/2.)))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRoundedRectangleProfileDef">
      <WhereRules>
        <WhereRule Name="ValidRadius">
          <Description>The value of the attribute RoundingRadius shall be lower or equal than either of both, half the value of the Xdim and the YDim attribute.</Description>
          <Definition> ((RoundingRadius &lt;= (SELF\IfcRectangleProfileDef.XDim/2.)) AND 
 (RoundingRadius &lt;= (SELF\IfcRectangleProfileDef.YDim/2.)))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTShapeProfileDef">
      <WhereRules>
        <WhereRule Name="ValidFlangeThickness">
          <Description>The flange thickness shall be smaller than the depth.</Description>
          <Definition> FlangeThickness &lt; Depth</Definition>
        </WhereRule>
        <WhereRule Name="ValidWebThickness">
          <Description>The web thickness shall be smaller than the flange width.</Description>
          <Definition> WebThickness &lt; FlangeWidth</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcUShapeProfileDef">
      <WhereRules>
        <WhereRule Name="ValidFlangeThickness">
          <Description>The flange thickness shall be smaller than half of the depth.</Description>
          <Definition> FlangeThickness &lt; (Depth / 2.)</Definition>
        </WhereRule>
        <WhereRule Name="ValidWebThickness">
          <Description>The web thickness shall be smaller than the flange width.</Description>
          <Definition> WebThickness &lt; FlangeWidth</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcZShapeProfileDef">
      <WhereRules>
        <WhereRule Name="ValidFlangeThickness">
          <Description>The flange thickness shall be smaller than half of the depth.</Description>
          <Definition> FlangeThickness &lt; (Depth / 2.)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcComplexProperty">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>The IfcComplexProperty should not reference itself within the list of HasProperties.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* HasProperties | SELF :=: temp)) = 0</Definition>
        </WhereRule>
        <WhereRule Name="WR22">
          <Description>Each property within the complex property shall have a unique name attribute.</Description>
          <Definition> IfcUniquePropertyName(HasProperties)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPropertyBoundedValue">
      <WhereRules>
        <WhereRule Name="SameUnitUpperLower">
          <Description>The measure type of the UpperBoundValue shall be the same as the measure type of the LowerBoundValue, if both (upper and lower bound) are given.</Description>
          <Definition> NOT(EXISTS(UpperBoundValue)) OR NOT(EXISTS(LowerBoundValue)) OR
(TYPEOF(UpperBoundValue) = TYPEOF(LowerBoundValue))</Definition>
        </WhereRule>
        <WhereRule Name="SameUnitUpperSet">
          <Description>The measure type of the UpperBoundValue shall be the same as the measure type of the SetPointValue, if both (upper bound and set point) are given.</Description>
          <Definition> NOT(EXISTS(UpperBoundValue)) OR NOT(EXISTS(SetPointValue)) OR
(TYPEOF(UpperBoundValue) = TYPEOF(SetPointValue))</Definition>
        </WhereRule>
        <WhereRule Name="SameUnitLowerSet">
          <Description>The measure type of the LowerBoundValue shall be the same as the measure type of the SetPointValue, if both (lower bound and set point) are given.</Description>
          <Definition> NOT(EXISTS(LowerBoundValue)) OR NOT(EXISTS(SetPointValue)) OR
(TYPEOF(LowerBoundValue) = TYPEOF(SetPointValue))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPropertyDependencyRelationship">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The DependingProperty shall not point to the same instance as the DependantProperty.</Description>
          <Definition> DependingProperty :&lt;&gt;: DependantProperty</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPropertyEnumeratedValue">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>Each value within the list of EnumerationValues shall be a member of the list of EnumerationValues at the referenced IfcPropertyEnumeration (provided that both, the EnumerationValues and EnumerationReference, are asserted).</Description>
          <Definition> NOT(EXISTS(EnumerationReference)) 
OR  NOT(EXISTS(EnumerationValues)) 
OR  (SIZEOF(QUERY(temp &lt;* EnumerationValues |
    temp IN EnumerationReference.EnumerationValues))
    = SIZEOF(EnumerationValues))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPropertyEnumeration">
      <WhereRules>
        <WhereRule Name="WR01">
          <Description>All values within the list of EnumerationValues shall be of the same measure type.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* SELF.EnumerationValues | 
  NOT(TYPEOF(SELF.EnumerationValues[1]) = TYPEOF(temp))
  )) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPropertyListValue">
      <WhereRules>
        <WhereRule Name="WR31">
          <Description>All values within the list of values shall be of the same measure type.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* SELF.ListValues | 
  NOT(TYPEOF(SELF.ListValues[1]) = TYPEOF(temp))
  )) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPropertyTableValue">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>Either both DefiningValues and DefinedValues are not provided, or the number of members in the list of DefiningValues shall be the same as the number of members in the list of DefinedValues.</Description>
          <Definition> (NOT(EXISTS(DefiningValues)) AND NOT(EXISTS(DefinedValues)))
OR (SIZEOF(DefiningValues) = SIZEOF(DefinedValues))</Definition>
        </WhereRule>
        <WhereRule Name="WR22">
          <Description>If DefiningValues are provided, then all values within the list of DefiningValues shall have the same measure type.</Description>
          <Definition> NOT(EXISTS(DefiningValues)) OR 
(SIZEOF(QUERY(temp &lt;* SELF.DefiningValues | TYPEOF(temp) &lt;&gt; TYPEOF(SELF.DefiningValues[1])
)) = 0)</Definition>
        </WhereRule>
        <WhereRule Name="WR23">
          <Description>If DefinedValues are provided, then all values within the list of DefinedValues shall have the same measure type.</Description>
          <Definition> NOT(EXISTS(DefinedValues)) OR 
(SIZEOF(QUERY(temp &lt;* SELF.DefinedValues | TYPEOF(temp) &lt;&gt; TYPEOF(SELF.DefinedValues[1])
)) = 0)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPhysicalComplexQuantity">
      <WhereRules>
        <WhereRule Name="NoSelfReference">
          <Description>The IfcPhysicalComplexQuantity should not reference itself within the list of HasQuantities.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* HasQuantities | SELF :=: temp)) = 0</Definition>
        </WhereRule>
        <WhereRule Name="UniqueQuantityNames">
          <Description>Every individual IfcPhysicalQuantity within the set HasQuantities shall have a unique Name attribute value.</Description>
          <Definition> IfcUniqueQuantityNames(HasQuantities)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcQuantityArea">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>If a unit is given, the unit type shall be area unit.</Description>
          <Definition> NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR
   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.AREAUNIT)</Definition>
        </WhereRule>
        <WhereRule Name="WR22">
          <Description>A valid area quantity shall be greater than or equal to zero.</Description>
          <Definition> AreaValue &gt;= 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcQuantityCount">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>The value of the count shall be greater than or equal to zero.</Description>
          <Definition> CountValue &gt;= 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcQuantityLength">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>If a unit is given, the unit type shall be a length unit.</Description>
          <Definition> NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR
   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.LENGTHUNIT)</Definition>
        </WhereRule>
        <WhereRule Name="WR22">
          <Description>A valid length quantity shall be greater than or equal to zero.</Description>
          <Definition> LengthValue &gt;= 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcQuantityTime">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>If a unit is given, the unit type shall be time unit.</Description>
          <Definition> NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR
   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.TIMEUNIT)</Definition>
        </WhereRule>
        <WhereRule Name="WR22">
          <Description>A valid weight quantity shall be greater than or equal to zero.</Description>
          <Definition> TimeValue &gt;= 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcQuantityVolume">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>If a unit is given, the unit type shall be volume unit.</Description>
          <Definition> NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR
   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.VOLUMEUNIT)</Definition>
        </WhereRule>
        <WhereRule Name="WR22">
          <Description>A valid volume quantity shall be greater than or equal to zero.</Description>
          <Definition> VolumeValue &gt;= 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcQuantityWeight">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>If a unit is given, the unit type shall be mass unit. NOTE  There is no distinction between the concept of "Mass" and "Weight" in the current IFC Release.</Description>
          <Definition> NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR
   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.MASSUNIT)</Definition>
        </WhereRule>
        <WhereRule Name="WR22">
          <Description>A valid weight quantity shall be greater than or equal to zero.</Description>
          <Definition> WeightValue &gt;= 0.</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcGeometricRepresentationContext">
      <WhereRules>
        <WhereRule Name="North2D">
          <Description>The TrueNorth direction, if provided, shall be a two-dimensional direction.</Description>
          <Definition> NOT(EXISTS(TrueNorth)) OR (HIINDEX(TrueNorth.DirectionRatios) = 2)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcGeometricRepresentationSubContext">
      <WhereRules>
        <WhereRule Name="ParentNoSub">
          <Description>The parent context shall not be another geometric representation sub context.</Description>
          <Definition> NOT('IFC4.IFCGEOMETRICREPRESENTATIONSUBCONTEXT' IN TYPEOF(ParentContext))</Definition>
        </WhereRule>
        <WhereRule Name="UserTargetProvided">
          <Description>The attribute UserDefinedTargetView shall be given, if the attribute TargetView is set to USERDEFINED.</Description>
          <Definition> (TargetView &lt;&gt; IfcGeometricProjectionEnum.USERDEFINED) OR 
((TargetView =  IfcGeometricProjectionEnum.USERDEFINED) AND EXISTS(UserDefinedTargetView))</Definition>
        </WhereRule>
        <WhereRule Name="NoCoordOperation">
          <Description>An IfcCoordinateOperation shall not be provided to a geometric representation sub context, only to the parent geometric representation context. 

NOTE  The coordinate operation is used to define the coordinate transformation of the project engineering coordinate system to a geographic coordinate reference system.</Description>
          <Definition> SIZEOF(SELF\IfcGeometricRepresentationContext.HasCoordinateOperation) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcMaterialDefinitionRepresentation">
      <WhereRules>
        <WhereRule Name="OnlyStyledRepresentations">
          <Description>Only representations of type IfcStyledRepresentation should be used to represent material through the IfcMaterialRepresentation.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* Representations | 
  (NOT('IFC4.IFCSTYLEDREPRESENTATION' IN TYPEOF(temp)))
)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcProductDefinitionShape">
      <WhereRules>
        <WhereRule Name="OnlyShapeModel">
          <Description>Only representations of type IfcShapeModel, i.e. either IfcShapeRepresentation or IfcTopologyRepresentation should be used to represent a product through the IfcProductDefinitionShape.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* Representations | 
  (NOT('IFC4.IFCSHAPEMODEL' IN TYPEOF(temp)))
)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcProjectedCRS">
      <WhereRules>
        <WhereRule Name="IsLengthUnit">
          <Description>The map unit shall be given, if present, as a length unit.</Description>
          <Definition> NOT(EXISTS(MapUnit)) OR (MapUnit.UnitType = IfcUnitEnum.LENGTHUNIT)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcShapeModel">
      <WhereRules>
        <WhereRule Name="WR11">
          <Description>The IfcShapeModel shall be used by an IfcProductRepresentation, by an IfcRepresentationMap or by an IfcShapeAspect.</Description>
          <Definition> (SIZEOF(SELF\IfcRepresentation.OfProductRepresentation) = 1) XOR 
(SIZEOF(SELF\IfcRepresentation.RepresentationMap) = 1) XOR
(SIZEOF(OfShapeAspect) = 1)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcShapeRepresentation">
      <WhereRules>
        <WhereRule Name="CorrectContext">
          <Description>The context to which the IfcShapeRepresentation is assign, shall be of type IfcGeometricRepresentationContext.</Description>
          <Definition> 'IFC4.IFCGEOMETRICREPRESENTATIONCONTEXT' 
IN TYPEOF(SELF\IfcRepresentation.ContextOfItems)</Definition>
        </WhereRule>
        <WhereRule Name="NoTopologicalItem">
          <Description>No topological representation item shall be directly used for shape representations, with the exception of IfcVertexPoint, IfcEdgeCurve, IfcFaceSurface.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* Items | 
  ('IFC4.IFCTOPOLOGICALREPRESENTATIONITEM' IN TYPEOF(temp))
    AND (NOT(SIZEOF(
      ['IFC4.IFCVERTEXPOINT',
       'IFC4.IFCEDGECURVE',
       'IFC4.IFCFACESURFACE'] * TYPEOF(temp)) = 1))
)) = 0</Definition>
        </WhereRule>
        <WhereRule Name="HasRepresentationType">
          <Description>A representation type should be provided for the shape representation.</Description>
          <Definition> EXISTS(SELF\IfcRepresentation.RepresentationType)</Definition>
        </WhereRule>
        <WhereRule Name="CorrectItemsForType">
          <Description>Checks the proper use of Items according to the RepresentationType.</Description>
          <Definition> IfcShapeRepresentationTypes(SELF\IfcRepresentation.RepresentationType, SELF\IfcRepresentation.Items)</Definition>
        </WhereRule>
        <WhereRule Name="HasRepresentationIdentifier">
          <Description>A representation identifier should be provided for the shape representation.</Description>
          <Definition> EXISTS(SELF\IfcRepresentation.RepresentationIdentifier)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStyledRepresentation">
      <WhereRules>
        <WhereRule Name="OnlyStyledItems">
          <Description>Only IfcStyledItem's (or subtypes) are allowed as members in the list of Items, inherited from IfcRepresentation.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* SELF\IfcRepresentation.Items | 
  (NOT('IFC4.IFCSTYLEDITEM' IN TYPEOF(temp)))
)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTopologyRepresentation">
      <WhereRules>
        <WhereRule Name="WR21">
          <Description>Only topological representation items should be used.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* SELF\IfcRepresentation.Items | 
  NOT('IFC4.IFCTOPOLOGICALREPRESENTATIONITEM' IN TYPEOF(temp))
)) = 0</Definition>
        </WhereRule>
        <WhereRule Name="WR22">
          <Description>A representation type should be given to the topology representation.</Description>
          <Definition> EXISTS(SELF\IfcRepresentation.RepresentationType)</Definition>
        </WhereRule>
        <WhereRule Name="WR23">
          <Description>Checks the proper use of Items according to the RepresentationType.</Description>
          <Definition> IfcTopologyRepresentationTypes(SELF\IfcRepresentation.RepresentationType, SELF\IfcRepresentation.Items)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBeam">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcBeamType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcBeamTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcBeamTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no beam type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcBeamType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCBEAMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBeamStandardCase">
      <WhereRules>
        <WhereRule Name="HasMaterialProfileSetUsage">
          <Description>A valid instance of IfcBeamStandardCase relies on the provision of an IfcMaterialProfileSetUsage.</Description>
          <Definition> SIZEOF (QUERY(temp &lt;* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |
              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND
              ('IFC4.IFCMATERIALPROFILESETUSAGE' IN TYPEOF(temp.RelatingMaterial))
              )) = 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBeamType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcBeamTypeEnum.USERDEFINED) OR
((PredefinedType = IfcBeamTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBuildingElementProxy">
      <WhereRules>
        <WhereRule Name="HasObjectName">
          <Description>A Name attribute should be asserted for a building element proxy.</Description>
          <Definition> EXISTS(SELF\IfcRoot.Name)</Definition>
        </WhereRule>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcBuildingElementProxyType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcBuildingElementProxyTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcBuildingElementProxyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no building element proxy type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcBuildingElementProxyType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCBUILDINGELEMENTPROXYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBuildingElementProxyType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcBuildingElementProxyTypeEnum.USERDEFINED) OR
((PredefinedType = IfcBuildingElementProxyTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcChimney">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcChimneyType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcChimneyTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcChimneyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no chimney type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcChimneyType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCCHIMNEYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcChimneyType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcChimneyTypeEnum.USERDEFINED) OR
((PredefinedType = IfcChimneyTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcColumn">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcColumnType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcColumnTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcColumnTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no column type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcColumnType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCCOLUMNTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcColumnStandardCase">
      <WhereRules>
        <WhereRule Name="HasMaterialProfileSetUsage">
          <Description>A valid instance of IfcColumnStandardCase relies on the provision of an IfcMaterialProfileSetUsage.</Description>
          <Definition> SIZEOF (QUERY(temp &lt;* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |
              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND
              ('IFC4.IFCMATERIALPROFILESETUSAGE' IN TYPEOF(temp.RelatingMaterial))
              )) = 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcColumnType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcColumnTypeEnum.USERDEFINED) OR
((PredefinedType = IfcColumnTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCovering">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCoveringType is associated), or the inherited attribute ObjectType shall be given, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR 
 (PredefinedType &lt;&gt; IfcCoveringTypeEnum.USERDEFINED) OR 
 ((PredefinedType = IfcCoveringTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no covering type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCoveringType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCCOVERINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCoveringType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcCoveringTypeEnum.USERDEFINED) OR
((PredefinedType = IfcCoveringTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCurtainWall">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcCurtainWallType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcCurtainWallTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcCurtainWallTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no curtain wall type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcCurtainWallType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCCURTAINWALLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcCurtainWallType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcCurtainWallTypeEnum.USERDEFINED) OR
((PredefinedType = IfcCurtainWallTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDoor">
      <WhereRules>
        <WhereRule Name="CorrectStyleAssigned">
          <Description>Either there is no door type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcDoorType. 

NOTEnbsp; The deprecated type IfcDoorStyle is still included for backward compatibility reasons.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) 
OR ('IFC4.IFCDOORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDoorType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcDoorTypeEnum.USERDEFINED) OR
((PredefinedType = IfcDoorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcMember">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcMemberType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcMemberTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcMemberTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no member type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcMemberType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCMEMBERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcMemberStandardCase">
      <WhereRules>
        <WhereRule Name="HasMaterialProfileSetUsage">
          <Description>A valid instance of IfcMemberStandardCase relies on the provision of an IfcMaterialProfileSetUsage.</Description>
          <Definition> SIZEOF (QUERY(temp &lt;* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |
              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND
              ('IFC4.IFCMATERIALPROFILESETUSAGE' IN TYPEOF(temp.RelatingMaterial))
              )) = 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcMemberType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcMemberTypeEnum.USERDEFINED) OR
((PredefinedType = IfcMemberTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPlate">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcPlateType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcPlateTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcPlateTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no plate type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcPlateType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCPLATETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPlateStandardCase">
      <WhereRules>
        <WhereRule Name="HasMaterialLayerSetUsage">
          <Description>A valid instance of IfcPlateStandardCase relies on the provision of an IfcMaterialLayerSetUsage.</Description>
          <Definition> SIZEOF (QUERY(temp &lt;* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |
              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND
              ('IFC4.IFCMATERIALLAYERSETUSAGE' IN TYPEOF(temp.RelatingMaterial))
              )) = 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPlateType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcPlateTypeEnum.USERDEFINED) OR
((PredefinedType = IfcPlateTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRailing">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcRailingType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcRailingTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcRailingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no railing type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcRailingType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCRAILINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRailingType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcRailingTypeEnum.USERDEFINED) OR
((PredefinedType = IfcRailingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRamp">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcRampType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcRampTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcRampTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no ramp type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcRampType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCRAMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRampFlight">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcRampFlightType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcRampFlightTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcRampFlightTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no ramp flight type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcRampFlightType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCRAMPFLIGHTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRampFlightType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcRampFlightTypeEnum.USERDEFINED) OR
((PredefinedType = IfcRampFlightTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRampType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcRampTypeEnum.USERDEFINED) OR
((PredefinedType = IfcRampTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRelConnectsPathElements">
      <WhereRules>
        <WhereRule Name="NormalizedRelatingPriorities">
          <Description>The RelatingProperties shall all be given as a normalized integer range [0..100], where 0 is the lowest and 100 the highest priority of the material layers.</Description>
          <Definition> (SIZEOF(RelatingPriorities) = 0)
OR
(SIZEOF (QUERY (temp &lt;* RelatingPriorities
  | {0 &lt;= temp &lt;= 100}
  )) = SIZEOF(RelatingPriorities))</Definition>
        </WhereRule>
        <WhereRule Name="NormalizedRelatedPriorities">
          <Description>The RelatedProperties shall all be given as a normalized integer range [0..100], where 0 is the lowest and 100 the highest priority of the material layers.</Description>
          <Definition> (SIZEOF(RelatedPriorities) = 0)
OR
(SIZEOF (QUERY (temp &lt;* RelatedPriorities
  | {0 &lt;= temp &lt;= 100}
  )) = SIZEOF(RelatedPriorities))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRoof">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcRoofType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcRoofTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcRoofTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no roof type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcRoofType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCROOFTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcRoofType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcRoofTypeEnum.USERDEFINED) OR
((PredefinedType = IfcRoofTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcShadingDevice">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcShadingDeviceType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcShadingDeviceTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcShadingDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no shading device type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcShadingDeviceType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCSHADINGDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcShadingDeviceType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcShadingDeviceTypeEnum.USERDEFINED) OR
((PredefinedType = IfcShadingDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSlab">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcSlabType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcSlabTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcSlabTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no slab type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcSlabType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCSLABTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSlabElementedCase">
      <WhereRules>
        <WhereRule Name="HasDecomposition">
          <Description>A valid instance of IfcSlabElementedCase has to have parts in a decomposition hierarchy.</Description>
          <Definition> HIINDEX(SELF\IfcObjectDefinition.IsDecomposedBy) &gt; 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSlabStandardCase">
      <WhereRules>
        <WhereRule Name="HasMaterialLayerSetusage">
          <Description>A valid instance of IfcSlabStandardCase relies on the provision of an IfcMaterialLayerSetUsage.</Description>
          <Definition> SIZEOF (QUERY(temp &lt;* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |
              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND
              ('IFC4.IFCMATERIALLAYERSETUSAGE' IN TYPEOF(temp.RelatingMaterial))
              )) = 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSlabType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcSlabTypeEnum.USERDEFINED) OR
((PredefinedType = IfcSlabTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStair">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcStairType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcStairTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcStairTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no stair type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcStairType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCSTAIRTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStairFlight">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcStairFlightType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcStairFlightTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcStairFlightTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no stair flight type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcStairFlightType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCSTAIRFLIGHTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStairFlightType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcStairFlightTypeEnum.USERDEFINED) OR
((PredefinedType = IfcStairFlightTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStairType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcStairTypeEnum.USERDEFINED) OR
((PredefinedType = IfcStairTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWall">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcWallType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
 (PredefinedType &lt;&gt; IfcWallTypeEnum.USERDEFINED) OR
 ((PredefinedType = IfcWallTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>Either there is no wall type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcWallType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
  ('IFC4.IFCWALLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWallElementedCase">
      <WhereRules>
        <WhereRule Name="HasDecomposition">
          <Description>A valid instance of IfcWallElementedCase has to have parts in a decomposition hierarchy.</Description>
          <Definition> HIINDEX(SELF\IfcObjectDefinition.IsDecomposedBy) &gt; 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWallStandardCase">
      <WhereRules>
        <WhereRule Name="HasMaterialLayerSetUsage">
          <Description>A valid instance of IfcWallStandardCase relies on the provision of an IfcMaterialLayerSetUsage.</Description>
          <Definition> SIZEOF (QUERY(temp &lt;* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |
              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND
              ('IFC4.IFCMATERIALLAYERSETUSAGE' IN TYPEOF(temp.RelatingMaterial))
              )) = 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWallType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcWallTypeEnum.USERDEFINED) OR
((PredefinedType = IfcWallTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWindow">
      <WhereRules>
        <WhereRule Name="CorrectStyleAssigned">
          <Description>Either there is no door type object associated, i.e. the IsTypedBy inverse relationship is not provided, or the associated type object has to be of type IfcWindowStyle. 

NOTEnbsp; The deprecated type IfcWindowStyle is still included for backward compatibility reasons.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) 
OR ('IFC4.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcWindowType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcWindowTypeEnum.USERDEFINED) OR
((PredefinedType = IfcWindowTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBuildingElementPart">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcBuildingElementPartType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
(PredefinedType &lt;&gt; IfcBuildingElementPartTypeEnum.USERDEFINED) OR
((PredefinedType = IfcBuildingElementPartTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>If this occurrence is defined by a type object, the latter has to be an IfcBuildingElementPartType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
('IFC4.IFCBUILDINGELEMENTPARTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcBuildingElementPartType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcBuildingElementPartTypeEnum.USERDEFINED) OR
((PredefinedType = IfcBuildingElementPartTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDiscreteAccessory">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcDiscreteAccessoryType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
(PredefinedType &lt;&gt; IfcDiscreteAccessoryTypeEnum.USERDEFINED) OR
((PredefinedType = IfcDiscreteAccessoryTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>If this occurrence is defined by a type object, the latter has to be an IfcDiscreteAccessoryType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
('IFC4.IFCDISCRETEACCESSORYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcDiscreteAccessoryType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcDiscreteAccessoryTypeEnum.USERDEFINED) OR
((PredefinedType = IfcDiscreteAccessoryTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFastener">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcFastenerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
(PredefinedType &lt;&gt; IfcFastenerTypeEnum.USERDEFINED) OR
((PredefinedType = IfcFastenerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>If this occurrence is defined by a type object, the latter has to be an IfcFastenerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
('IFC4.IFCFASTENERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFastenerType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcFastenerTypeEnum.USERDEFINED) OR
((PredefinedType = IfcFastenerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcMechanicalFastener">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcMechanicalFastenerType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
(PredefinedType &lt;&gt; IfcMechanicalFastenerTypeEnum.USERDEFINED) OR
((PredefinedType = IfcMechanicalFastenerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>If this occurrence is defined by a type object, the latter has to be an IfcMechanicalFastenerType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
('IFC4.IFCMECHANICALFASTENERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcMechanicalFastenerType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcMechanicalFastenerTypeEnum.USERDEFINED) OR
((PredefinedType = IfcMechanicalFastenerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcOccupant">
      <WhereRules>
        <WhereRule Name="WR31">
          <Description>The attribute ObjectType must be asserted when the value of the IfcOccupantTypeEnum is set to USERDEFINED.</Description>
          <Definition> NOT(PredefinedType = IfcOccupantTypeEnum.USERDEFINED) 
OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralAnalysisModel">
      <WhereRules>
        <WhereRule Name="HasObjectType">
          <Description>The attribute ObjectType shall be given if the predefined type is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcAnalysisModelTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralCurveAction">
      <WhereRules>
        <WhereRule Name="ProjectedIsGlobal">
          <Description>A load can only be related to projected length if it was specified in global coordinate directions (i.e. in analysis model coordinate directions). If a load was specified in local coordinate directions, it can only relate to true length.</Description>
          <Definition> (NOT EXISTS(ProjectedOrTrue)) OR
((ProjectedOrTrue &lt;&gt; PROJECTED_LENGTH) OR
 (SELF\IfcStructuralActivity.GlobalOrLocal = GLOBAL_COORDS))</Definition>
        </WhereRule>
        <WhereRule Name="HasObjectType">
          <Description>The attribute ObjectType shall be given if the predefined type is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcStructuralCurveActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
        <WhereRule Name="SuitablePredefinedType">
          <Description>The EQUIDISTANT distribution type is out of scope of structural curve actions.</Description>
          <Definition> PredefinedType &lt;&gt; IfcStructuralCurveActivityTypeEnum.EQUIDISTANT</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralCurveMember">
      <WhereRules>
        <WhereRule Name="HasObjectType">
          <Description>The attribute ObjectType shall be given if the predefined type is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcStructuralCurveMemberTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralCurveReaction">
      <WhereRules>
        <WhereRule Name="HasObjectType">
          <Description>The attribute ObjectType shall be given if the predefined type is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcStructuralCurveActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
        <WhereRule Name="SuitablePredefinedType">
          <Description>The SINUS and PARABOLA distribution types are out of scope of structural curve reactions.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcStructuralCurveActivityTypeEnum.SINUS) AND (PredefinedType &lt;&gt; IfcStructuralCurveActivityTypeEnum.PARABOLA)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralLinearAction">
      <WhereRules>
        <WhereRule Name="SuitableLoadType">
          <Description>A linear action shall place either a linear force or a temperature load.</Description>
          <Definition> SIZEOF(['IFC4.IFCSTRUCTURALLOADLINEARFORCE', 'IFC4.IFCSTRUCTURALLOADTEMPERATURE'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1</Definition>
        </WhereRule>
        <WhereRule Name="ConstPredefinedType">
          <Description>This curve action subtype is restricted to constant load distribution over its domain.</Description>
          <Definition> SELF\IfcStructuralCurveAction.PredefinedType = IfcStructuralCurveActivityTypeEnum.CONST</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralLoadCase">
      <WhereRules>
        <WhereRule Name="IsLoadCasePredefinedType">
          <Description>An instance of this subtype of structural load group cannot be of any other type than that of a load case.</Description>
          <Definition> SELF\IfcStructuralLoadGroup.PredefinedType = IfcLoadGroupTypeEnum.LOAD_CASE</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralLoadGroup">
      <WhereRules>
        <WhereRule Name="HasObjectType">
          <Description>The attribute ObjectType shall be given if the predefined type, action type, or action source is set to USERDEFINED.</Description>
          <Definition> (
  (PredefinedType &lt;&gt; IfcLoadGroupTypeEnum.USERDEFINED) AND
  (ActionType &lt;&gt; IfcActionTypeEnum.USERDEFINED) AND
  (ActionSource &lt;&gt; IfcActionSourceTypeEnum.USERDEFINED)
) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralPlanarAction">
      <WhereRules>
        <WhereRule Name="SuitableLoadType">
          <Description>A planar action shall place either a planar force or a temperature load.</Description>
          <Definition> SIZEOF(['IFC4.IFCSTRUCTURALLOADPLANARFORCE', 'IFC4.IFCSTRUCTURALLOADTEMPERATURE'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1</Definition>
        </WhereRule>
        <WhereRule Name="ConstPredefinedType">
          <Description>This surface action subtype is restricted to constant load distribution over its domain.</Description>
          <Definition> SELF\IfcStructuralSurfaceAction.PredefinedType = IfcStructuralSurfaceActivityTypeEnum.CONST</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralPointAction">
      <WhereRules>
        <WhereRule Name="SuitableLoadType">
          <Description>A structural point action shall place either a single force or a single displacement.</Description>
          <Definition> SIZEOF(['IFC4.IFCSTRUCTURALLOADSINGLEFORCE', 'IFC4.IFCSTRUCTURALLOADSINGLEDISPLACEMENT'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralPointReaction">
      <WhereRules>
        <WhereRule Name="SuitableLoadType">
          <Description>A structural point reaction shall have as a result either a single force or a single displacement.</Description>
          <Definition> SIZEOF(['IFC4.IFCSTRUCTURALLOADSINGLEFORCE', 'IFC4.IFCSTRUCTURALLOADSINGLEDISPLACEMENT'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralResultGroup">
      <WhereRules>
        <WhereRule Name="HasObjectType">
          <Description>The attribute ObjectType shall be given if the analysis theory type is set to USERDEFINED.</Description>
          <Definition> (TheoryType &lt;&gt; IfcAnalysisTheoryTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralSurfaceAction">
      <WhereRules>
        <WhereRule Name="ProjectedIsGlobal">
          <Description>A load can only be related to projected lengths if it was specified in global coordinate directions (i.e. in analysis model coordinate directions). If a load was specified in local coordinate directions, it can only relate to true lengths.</Description>
          <Definition> (NOT EXISTS(ProjectedOrTrue)) OR
((ProjectedOrTrue &lt;&gt; PROJECTED_LENGTH) OR
 (SELF\IfcStructuralActivity.GlobalOrLocal = GLOBAL_COORDS))</Definition>
        </WhereRule>
        <WhereRule Name="HasObjectType">
          <Description>The attribute ObjectType shall be given if the predefined type is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcStructuralSurfaceActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralSurfaceMember">
      <WhereRules>
        <WhereRule Name="HasObjectType">
          <Description>The attribute ObjectType shall be given if the predefined type is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcStructuralSurfaceMemberTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralSurfaceReaction">
      <WhereRules>
        <WhereRule Name="HasPredefinedType">
          <Description>The attribute ObjectType shall be given if the predefined type is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcStructuralSurfaceActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFooting">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcFootingType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT EXISTS(PredefinedType) OR
(PredefinedType &lt;&gt; IfcFootingTypeEnum.USERDEFINED) OR
((PredefinedType = IfcFootingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>If this occurrence is defined by a type object, the latter has to be an IfcFootingType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
('IFC4.IFCFOOTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFootingType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcFootingTypeEnum.USERDEFINED) OR
((PredefinedType = IfcFootingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPile">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcPileType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT EXISTS(PredefinedType) OR
(PredefinedType &lt;&gt; IfcPileTypeEnum.USERDEFINED) OR
((PredefinedType = IfcPileTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>If this occurrence is defined by a type object, the latter has to be an IfcPileType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
('IFC4.IFCPILETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPileType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcPileTypeEnum.USERDEFINED) OR
((PredefinedType = IfcPileTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcReinforcingBar">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcReinforcingBarType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT EXISTS(PredefinedType) OR
(PredefinedType &lt;&gt; IfcReinforcingBarTypeEnum.USERDEFINED) OR
((PredefinedType = IfcReinforcingBarTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>If this occurrence is defined by a type object, the latter has to be an IfcReinforcingBarType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
('IFC4.IFCREINFORCINGBARTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcReinforcingBarType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcReinforcingBarTypeEnum.USERDEFINED) OR
((PredefinedType = IfcReinforcingBarTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
        <WhereRule Name="BendingShapeCodeProvided">
          <Description>Bending parameters must be accompanied by a shape code.</Description>
          <Definition> NOT EXISTS(BendingParameters) OR EXISTS(BendingShapeCode)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcReinforcingMesh">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcReinforcingMeshType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT EXISTS(PredefinedType) OR
(PredefinedType &lt;&gt; IfcReinforcingMeshTypeEnum.USERDEFINED) OR
((PredefinedType = IfcReinforcingMeshTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>If this occurrence is defined by a type object, the latter has to be an IfcReinforcingMeshType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
('IFC4.IFCREINFORCINGMESHTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcReinforcingMeshType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcReinforcingMeshTypeEnum.USERDEFINED) OR
((PredefinedType = IfcReinforcingMeshTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
        <WhereRule Name="BendingShapeCodeProvided">
          <Description>Bending parameters must be accompanied by a shape code.</Description>
          <Definition> NOT EXISTS(BendingParameters) OR EXISTS(BendingShapeCode)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSurfaceFeature">
      <WhereRules>
        <WhereRule Name="HasObjectType">
          <Description>The attribute ObjectType shall be given if the predefined type is set to USERDEFINED.</Description>
          <Definition> NOT EXISTS(PredefinedType) OR (PredefinedType &lt;&gt; IfcSurfaceFeatureTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTendon">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcTendonType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
(PredefinedType &lt;&gt; IfcTendonTypeEnum.USERDEFINED) OR
((PredefinedType = IfcTendonTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>If this occurrence is defined by a type object, the latter has to be an IfcTendonType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
('IFC4.IFCTENDONTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTendonAnchor">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>Either the PredefinedType attribute is unset (e.g. because an IfcTendonAnchorType is associated), or the inherited attribute ObjectType shall be provided, if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> NOT(EXISTS(PredefinedType)) OR
(PredefinedType &lt;&gt; IfcTendonAnchorTypeEnum.USERDEFINED) OR
((PredefinedType = IfcTendonAnchorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType))</Definition>
        </WhereRule>
        <WhereRule Name="CorrectTypeAssigned">
          <Description>If this occurrence is defined by a type object, the latter has to be an IfcTendonAnchorType.</Description>
          <Definition> (SIZEOF(IsTypedBy) = 0) OR
('IFC4.IFCTENDONANCHORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTendonAnchorType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcTendonAnchorTypeEnum.USERDEFINED) OR
((PredefinedType = IfcTendonAnchorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTendonType">
      <WhereRules>
        <WhereRule Name="CorrectPredefinedType">
          <Description>The inherited attribute ElementType shall be provided if the PredefinedType is set to USERDEFINED.</Description>
          <Definition> (PredefinedType &lt;&gt; IfcTendonTypeEnum.USERDEFINED) OR
((PredefinedType = IfcTendonTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcVoidingFeature">
      <WhereRules>
        <WhereRule Name="HasObjectType">
          <Description>The attribute ObjectType shall be given if the predefined type is set to USERDEFINED.</Description>
          <Definition> NOT EXISTS(PredefinedType) OR (PredefinedType &lt;&gt; IfcVoidingFeatureTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcStructuralLoadConfiguration">
      <WhereRules>
        <WhereRule Name="ValidListSize">
          <Description>If locations are provided, there shall be as many location items as there are value items.</Description>
          <Definition> NOT EXISTS(Locations) OR (SIZEOF(Locations) = SIZEOF(Values))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcSurfaceReinforcementArea">
      <WhereRules>
        <WhereRule Name="SurfaceAndOrShearAreaSpecified">
          <Description>At least one of the reinforcement area attributes shall be specified.</Description>
          <Definition> EXISTS(SurfaceReinforcement1) OR EXISTS(SurfaceReinforcement2) OR EXISTS(ShearReinforcement)</Definition>
        </WhereRule>
        <WhereRule Name="NonnegativeArea1">
          <Description>Surface reinforcement area must not be less than 0.</Description>
          <Definition> (NOT EXISTS(SurfaceReinforcement1)) OR (
    (SurfaceReinforcement1[1] &gt;= 0.) AND
    (SurfaceReinforcement1[2] &gt;= 0.) AND
    ((SIZEOF(SurfaceReinforcement1) = 1) OR (SurfaceReinforcement1[1] &gt;= 0.))
)</Definition>
        </WhereRule>
        <WhereRule Name="NonnegativeArea2">
          <Description>Surface reinforcement area must not be less than 0.</Description>
          <Definition> (NOT EXISTS(SurfaceReinforcement2)) OR (
    (SurfaceReinforcement2[1] &gt;= 0.) AND
    (SurfaceReinforcement2[2] &gt;= 0.) AND
    ((SIZEOF(SurfaceReinforcement2) = 1) OR (SurfaceReinforcement2[1] &gt;= 0.))
)</Definition>
        </WhereRule>
        <WhereRule Name="NonnegativeArea3">
          <Description>Shear reinforcement area must not be less than 0.</Description>
          <Definition> (NOT EXISTS(ShearReinforcement)) OR (ShearReinforcement &gt;= 0.)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcAdvancedFace">
      <WhereRules>
        <WhereRule Name="ApplicableSurface">
          <Description>The geometry used in the definition of the face shall be restricted. The face geometry shall be an IfcElementarySurface, IfcSweptSurface, or IfcBSplineSurface.</Description>
          <Definition> SIZEOF (
['IFC4.IFCELEMENTARYSURFACE',
 'IFC4.IFCSWEPTSURFACE',
 'IFC4.IFCBSPLINESURFACE'] *
TYPEOF(SELF\IfcFaceSurface.FaceSurface)) = 1</Definition>
        </WhereRule>
        <WhereRule Name="RequiresEdgeCurve">
          <Description>The geometry of all bounding edges of the face shall be fully defined as IfcEdgeCurve's.</Description>
          <Definition> SIZEOF(QUERY (ElpFbnds &lt;* 
  QUERY (Bnds &lt;* SELF\IfcFace.Bounds |
    'IFC4.IFCEDGELOOP' IN TYPEOF(Bnds.Bound)) |
     NOT (SIZEOF (QUERY (Oe &lt;* ElpFbnds.Bound\IfcEdgeLoop.EdgeList |
       NOT('IFC4.IFCEDGECURVE' IN 
       TYPEOF(Oe\IfcOrientedEdge.EdgeElement)
  ))) = 0
))) = 0</Definition>
        </WhereRule>
        <WhereRule Name="ApplicableEdgeCurves">
          <Description>The types of curve used to define the geometry of edges shall be restricted to IfcLine, IfcConic, IfcPolyline, or IfcBSplineCurve.</Description>
          <Definition> SIZEOF(QUERY (ElpFbnds &lt;* 
  QUERY (Bnds &lt;* SELF\IfcFace.Bounds |
    'IFC4.IFCEDGELOOP' IN TYPEOF(Bnds.Bound)) |
     NOT (SIZEOF (QUERY (Oe &lt;* ElpFbnds.Bound\IfcEdgeLoop.EdgeList |
       NOT (SIZEOF (['IFC4.IFCLINE',
                     'IFC4.IFCCONIC',
                     'IFC4.IFCPOLYLINE',
                     'IFC4.IFCBSPLINECURVE'] *
         TYPEOF(Oe\IfcOrientedEdge.EdgeElement\IfcEdgeCurve.EdgeGeometry)) = 1 )
  )) = 0
))) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcEdgeLoop">
      <WhereRules>
        <WhereRule Name="IsClosed">
          <Description>The start vertex of the first edge shall be the same as the end vertex of the last edge. This ensures that the path is closed to form a loop.</Description>
          <Definition> (EdgeList[1].EdgeStart) :=: (EdgeList[Ne].EdgeEnd)</Definition>
        </WhereRule>
        <WhereRule Name="IsContinuous">
          <Description>The end vertex of each edge shall be the same as the start vertex of its successor.</Description>
          <Definition> IfcLoopHeadToTail(SELF)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcFace">
      <WhereRules>
        <WhereRule Name="HasOuterBound">
          <Description>At most one of the bounds shall be of the type IfcFaceOuterBound. 

NOTE  If the IfcFace is used within an IfcFacetedBrep, where all faces are implicitly planar and having a disctinct outer bound, exactly one of the bounds shall be of the type IfcFaceOuterBound.</Description>
          <Definition> SIZEOF(QUERY(temp &lt;* Bounds | 'IFC4.IFCFACEOUTERBOUND' IN TYPEOF(temp))) &lt;= 1</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcOrientedEdge">
      <WhereRules>
        <WhereRule Name="EdgeElementNotOriented">
          <Description>The edge element shall not be an oriented edge.</Description>
          <Definition> NOT('IFC4.IFCORIENTEDEDGE' IN TYPEOF(EdgeElement))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPath">
      <WhereRules>
        <WhereRule Name="IsContinuous">
          <Description>The end vertex of each edge shall be the same as the start vertex of its successor.</Description>
          <Definition> IfcPathHeadToTail(SELF)</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcPolyLoop">
      <WhereRules>
        <WhereRule Name="AllPointsSameDim">
          <Description>The space dimensionality of all Points shall be the same.</Description>
          <Definition> SIZEOF(QUERY(Temp &lt;* Polygon | Temp.Dim &lt;&gt; Polygon[1].Dim)) = 0</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcOwnerHistory">
      <WhereRules>
        <WhereRule Name="CorrectChangeAction">
          <Description>If ChangeAction is asserted and LastModifiedDate is not defined, ChangeAction must be set to NOTDEFINED</Description>
          <Definition> (EXISTS(LastModifiedDate)) OR
(NOT(EXISTS(LastModifiedDate)) AND NOT(EXISTS(ChangeAction))) OR
(NOT(EXISTS(LastModifiedDate)) AND EXISTS(ChangeAction) AND ((ChangeAction = IfcChangeActionEnum.NOTDEFINED) OR (ChangeAction = IfcChangeActionEnum.NOCHANGE)))</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
    <TypeRules Type="IfcTable">
      <WhereRules>
        <WhereRule Name="WR1">
          <Description>Ensures that each row defines the same number of cells. The rule compares whether all other rows of the IfcTable have the same number of cells as the first row.</Description>
          <Definition> SIZEOF(QUERY( Temp &lt;* Rows | HIINDEX(Temp.RowCells) &lt;&gt; HIINDEX(Rows[1].RowCells))) = 0</Definition>
        </WhereRule>
        <WhereRule Name="WR2">
          <Description>The rule restricts the allowed number of heading rows to no more than one.</Description>
          <Definition> { 0 &lt;= NumberOfHeadings &lt;= 1 }</Definition>
        </WhereRule>
      </WhereRules>
    </TypeRules>
  </TypeRulesSet>
</SchemaRules>