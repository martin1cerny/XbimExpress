<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

<# foreach(var u in Using) { #>
using <#= u #>;
<# } #>

namespace <#= Namespace #>
{
    // ReSharper disable once PartialTypeWithSinglePart
	public partial struct <#= Name #> <#= Inheritance #>
	{ 
		private <#= UnderlyingType #> _value;
        
		public object Value
        {
            get { return _value; }
        }

        public override string ToString()
        {
            return Value != null ? Value.ToString() : typeof(<#= UnderlyingType #>).Name;
        }

        public <#= Name #>(<#= UnderlyingType #> val)
        {
            _value = val;
        }

        public static implicit operator <#= Name #>(<#= UnderlyingType #> value)
        {
            return new <#= Name #>(value);
        }

        public static implicit operator <#= UnderlyingType #>(<#= Name #> obj)
        {
            return obj._value;
        }


        public override bool Equals(object obj)
        {
			if (obj == null && Value == null)
                return true;

            if (obj == null)
                return false;

            if (GetType() != obj.GetType())
                return false;

<#	if (!IsComplex) { #>
            return ((<#= Name #>) obj)._value == _value;
<#	} else { #>
            return System.Linq.Enumerable.SequenceEqual(((<#= Name #>) obj)._value, _value);
<#	} #>
        }

        public static bool operator ==(<#= Name #> obj1, <#= Name #> obj2)
        {
            return Equals(obj1, obj2);
        }

        public static bool operator !=(<#= Name #> obj1, <#= Name #> obj2)
        {
            return !Equals(obj1, obj2);
        }

        public override int GetHashCode()
        {
            return Value != null ? _value.GetHashCode() : base.GetHashCode();
        }

		#region <#= PersistInterface #> implementation
		void <#= PersistInterface #>.Parse(int propIndex, IPropertyValue value)
		{
			if (propIndex != 0)
				throw new XbimParserException(string.Format("Attribute index {0} is out of range for {1}", propIndex + 1, GetType().Name.ToUpper()));
<#	if (IsComplex) { #>
			if (_value == null)
				_value = new <#= UnderlyingType #>();
            _value.Add(value.<#= GetPropertyValueMember(Type.Domain) #>);

<#	} 
	else { #>
            _value = value.<#= GetPropertyValueMember(Type.Domain) #>;
<#	}#>            
		}

		string <#= PersistInterface #>.WhereRule()
		{
            throw new System.NotImplementedException();
		}
		#endregion

		#region IExpressType implementation
		string IExpressType.ToPart21 { 
			get 
			{
				throw new System.NotImplementedException();
			}
		}
        System.Type IExpressType.UnderlyingSystemType { 
			get 
			{
				return typeof(<#= UnderlyingType #>);
			}
		}
		#endregion

<# if (IsComplex) { #>
		#region IExpressComplexType implementation
		IEnumerable<object> IExpressComplexType.Properties
        {
            get
            {
				if(_value == null) yield break;
	            foreach (var value in _value)
	                yield return value;
            }
        }

		void IExpressComplexType.Add(object o)
	    {
			if (_value == null)
				_value = new <#= UnderlyingType #>();
			 _value.Add((<#= UnderlyingArrayType #>) o);
	    }
		#endregion
<# } #>

	}
}
